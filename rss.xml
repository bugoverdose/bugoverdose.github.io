<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed | bugoverdose]]></title><description><![CDATA[공부하고 경험한 내용을 깔끔하게 설명하는 것을 목표로 하는 개발 블로그입니다. 컴퓨터과학, 웹 개발 등 다양한 주제를 포괄적으로 다룹니다.]]></description><link>https://bugoverdose.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sat, 15 Jan 2022 08:59:36 GMT</lastBuildDate><item><title><![CDATA[메모리 회로의 핵심: 플립플롭의 이해]]></title><description><![CDATA[오늘은 입력값으로부터 0과 1이라는 출력값을 만들어내고, 외부로부터의 입력이 사라지더라도 그 출력값을 그대로 유지하는 구조의 회로에 대해 이야기해보고자 한다. 다양한 구조의 래치를 차근차근 살펴보며 최종적으로 D 플립플롭을 자세히 이해해보자.]]></description><link>https://bugoverdose.github.io/computer-science/latch-and-flip-flop/</link><guid isPermaLink="false">https://bugoverdose.github.io/computer-science/latch-and-flip-flop/</guid><pubDate>Thu, 13 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;&lt;div to=&quot;/computer-science/analog-and-digital&quot;&gt;지난 게시글&lt;/div&gt;&lt;/strong&gt;에서
우리는 안정성을 위해 입력되는 자극을
0과 1이라는 데이터로 간주하여 연산에 사용하는 것이
회로의 기본 원리라고 이야기하였다.
또한 &lt;strong&gt;&lt;div to=&quot;/computer-science/bit-and-logic-operation&quot;&gt;그 이전 게시글&lt;/div&gt;&lt;/strong&gt;에서는
이러한 0과 1이라는 데이터를 적절히 조합함으로써
보다 복잡한 데이터를 표현하고 다양한 연산을 수행할 수 있음을 설명하였다.
그러나 실제로 연산을 수행하기 위해서는
여전히 풀어야 할 과제가 존재한다.&lt;/p&gt;&lt;h2&gt;메모리의 필요성&lt;/h2&gt;&lt;p&gt;회로를 구성하는 개별 부품이 0 혹은 1이라는 출력값을 꾸준히 내기 위해서는
그에 해당되는 입력이 각 부품에 꾸준히 들어와야 한다.
그렇다면 예를 들어 &lt;code&gt;5+1&lt;/code&gt;라는 연산을 회로가 어떻게 처리할 수 있을까?
기본적으로 &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;에 해당되는 데이터를
3가지 입력 장치를 통해 &lt;em&gt;동시에&lt;/em&gt; 생성하고 연산의 결과가 나올 때까지
입력을 유지하는 방법을 생각해볼 수 있다.&lt;/p&gt;&lt;p&gt;단순히 두 수를 더하는 상황에서는 이 방법을 오답이라고 보기는 힘들다.
그러나 예를 들어 &lt;code&gt;5-1&lt;/code&gt;라는 연산을 수행하려는 경우에는 어떠할까?
덧셈과 달리 뺄셈과 나눗셈은 두 피연산자의 &lt;em&gt;순서&lt;/em&gt;가 굉장히 중요하다.
&lt;code&gt;5-1&lt;/code&gt;과 &lt;code&gt;1-5&lt;/code&gt;는 서로 다른 결과이니 말이다.
위와 같은 방법을 고수하고 싶다면 예를 들어
&lt;code&gt;5&lt;/code&gt;라는 데이터를 &lt;code&gt;좌측 5&lt;/code&gt;, &lt;code&gt;우측 5&lt;/code&gt;라는 두 가지로 구분하는 방법을 생각해볼 수 있다.
즉, &lt;code&gt;5-1&lt;/code&gt;라는 연산을 위해 &lt;code&gt;좌측 5&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;우측 1&lt;/code&gt;라는 데이터를
&lt;em&gt;동시에&lt;/em&gt; 3가지 입력 장치를 통해 회로에 생성한다는 것이다.
뭔가 찝찝하지만 이 방법을 도입한다고 해보자.
그렇다면 &lt;code&gt;5-4+1&lt;/code&gt;라는 연산은 어떻게 수행될 수 있을까?
여전히 &lt;code&gt;첫번째 5&lt;/code&gt;, &lt;code&gt;첫번째 -&lt;/code&gt;, &lt;code&gt;두번째 4&lt;/code&gt;, &lt;code&gt;두번째 +&lt;/code&gt;, &lt;code&gt;세번째 1&lt;/code&gt;이라는
데이터를 생성하기 위해 5가지 입력장치를 &lt;em&gt;동시에&lt;/em&gt; 사용해야 한다고 생각하는가?
딱 보아도 범용성이 떨어진다는 점을 느낄 수 있을 것이다.&lt;/p&gt;&lt;p&gt;실제 계산기의 경우 &lt;code&gt;5-1&lt;/code&gt;이라는 연산을 위해
&lt;code&gt;5&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;라는 데이터를 &lt;em&gt;순차적으로&lt;/em&gt; 입력한다.
즉, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;라는 버튼을 단 한번만 눌러도
회로 내에 각각에 대응되는 데이터가 순차적으로 생성되며,
이렇게 &lt;strong&gt;생성된 데이터가 회로 내에 유지된다&lt;/strong&gt;는 것이다.&lt;/p&gt;&lt;p&gt;오늘은 입력값으로부터 0과 1이라는 출력값을 만들어내고,
외부로부터의 입력이 사라지더라도
그 출력값을 그대로 유지하는 구조의 회로에 대해 이야기해보고자 한다.&lt;/p&gt;&lt;h2&gt;래치&lt;/h2&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:299px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/9c4c401041cbe1d47f69c5670e1f7987/aeb78/or-gate-latch.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:54.72972972972974%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABY0lEQVQoz31SyarCQBCcb/dD/AoPHlTEDXHFuIseIihJXBNU3OtRDR1G5aWgmWEyXVNdFQMA7/dbirhcLjgcDjgejz8VhqEU91EUxT26EsY+eDweyGazGAwGGA6HH9XtdtHpdGR1HAeZTEaIEwmpjg232w2r1Qq+78PzPGy3W3xjOp1it9slE57PZ1HX6/WQy+Uwn88xHo/RbrdRLpflQQXv7fd72JaxfkauVCpoNpuo1+sfithcKBRi0n6//6FQOYzNTtB013VRrVZxv9/l/Pl8yjcS8EFiNptJMDZ43+AfMACSqwKqJxqNhqhPpVJIp9PiLy3K5/OYTCYwr9dLQlAlbOS+1WqJpwTvKOjlZrORKdbrNa7XK06nk/xq7DVBEKBUKsklmk9varUaisXij2qeL5dLJMFwbr6iStVwklMxVTIQKlssFrFiLTuDOGWFBjMajYSApEycvukvouPbQdoK/wCMl0GS/TtwWQAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;OR 게이트 래치&quot; title=&quot;OR 게이트 래치&quot; src=&quot;/static/9c4c401041cbe1d47f69c5670e1f7987/aeb78/or-gate-latch.png&quot; srcSet=&quot;/static/9c4c401041cbe1d47f69c5670e1f7987/12f09/or-gate-latch.png 148w,/static/9c4c401041cbe1d47f69c5670e1f7987/e4a3f/or-gate-latch.png 295w,/static/9c4c401041cbe1d47f69c5670e1f7987/aeb78/or-gate-latch.png 299w&quot; sizes=&quot;(max-width: 299px) 100vw, 299px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;위와 같은 구조의 회로를 한번 보자.
초기 상태로 in에는 0이라는 값이 입력되며 이 때문에
OR 게이트의 출력값은 0이 된다고 가정하자(&lt;code&gt;0 OR 0 = 0&lt;/code&gt;).
이후 in에 1이라는 값이 입력되는 경우 OR 게이트의 출력값은 무조건 1이 되며,
out에는 1이라는 값이 출력된다.
그런데 이때 OR 게이트의 출력값인 1은 그대로 OR 게이트 자신의
입력값으로 들어오게 되며,
OR 게이트는 1과 1을 입력값으로 받아들이게 된다(&lt;code&gt;1 OR 1 = 1&lt;/code&gt;).
이렇게 출력값을 자신의 입력값으로 사용하는 순환구조를
피드백(feedback)이라고 한다.
그리고 이러한 피드백으로 인해 in의 입력값이 다시 0으로 변하더라도
OR 게이트의 출력값은 여전히 1로 유지될 수 있다(&lt;code&gt;0 OR 1 = 1&lt;/code&gt;).&lt;/p&gt;&lt;p&gt;이처럼 입력값을 외부로부터 꾸준히 입력받지 않더라도,
특정한 출력값을 유지할 수 있는 구조의 회로가 바로 &lt;strong&gt;래치(latch)&lt;/strong&gt;의 특성이다.
그러나 위와 같은 OR 게이트 래치로는
출력값을 1로 변경하고 이를 유지시키는 것은 가능하지만,
다시 출력값을 0으로 되돌리는 것은 불가능하다.
자유자재로 1로 값을 설정(set)하고 0으로 값을 리셋(reset)하기 위해서는
피드백 과정에 간섭할 수 있는 수단을 추가해야 한다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/ce0eb5c7816f92b4addf0c24a6ac907c/d0c0e/and-or-gate-latch.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:30.405405405405407%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA2ElEQVQY03VQ1wrEMAzL//9c6UOfukv33pvqkCHlODiDSSLbiiz1PA+YDH3X767rUFWVZF3XKMsSRVHIyTfxLMvQNM07r35JdIERRRHCMESapkiSBOd5Cn7fN6ZpwnVdkqy/hJpk33d4nveSHschCnTzPM/ywbIsCIJAlFEtcW6iQ+mVWOSwZVnwfR+GYcBxHBn8JuQZxzGGYRDcdV2Ypom+7yUVG9Z1FU9s2xZ/WKCScRxFTZ7nklTStq1g7N+2Tch5pwXc8l2Z/mhz/wW9o09UR0/5+W98AOYGy9zyC5/xAAAAAElFTkSuQmCC&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;AND-OR 게이트 래치&quot; title=&quot;AND-OR 게이트 래치&quot; src=&quot;/static/ce0eb5c7816f92b4addf0c24a6ac907c/fcda8/and-or-gate-latch.png&quot; srcSet=&quot;/static/ce0eb5c7816f92b4addf0c24a6ac907c/12f09/and-or-gate-latch.png 148w,/static/ce0eb5c7816f92b4addf0c24a6ac907c/e4a3f/and-or-gate-latch.png 295w,/static/ce0eb5c7816f92b4addf0c24a6ac907c/fcda8/and-or-gate-latch.png 590w,/static/ce0eb5c7816f92b4addf0c24a6ac907c/d0c0e/and-or-gate-latch.png 715w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;위는 기존 구성에서 AND 게이트와 NOT 게이트(혹은 인버터)를 추가한 결과이다.
reset에 0이라는 값이 들어오는 동안 set의 입력값을 0에서 1로 변경하면
출력값은 0에서 1로 변하며, AND 게이트 역시 1을 출력함으로써(&lt;code&gt;1 AND 1 = 1&lt;/code&gt;)
OR 게이트에는 1이라는 값이 그대로 들어오게 된다.
그리고 set의 값이 다시 0으로 돌아가더라도
AND 게이트와 OR 게이트는 여전히 1을 출력하기 때문에(&lt;code&gt;1 AND 1 = 1&lt;/code&gt;; &lt;code&gt;1 OR 0 = 1&lt;/code&gt;)
out은 여전히 1로 유지된다.
이는 in이 set이라는 표현으로 변경되었을 뿐 이전과 동일한 논리라고 볼 수 있다.
다만, reset의 값이 1로 변할 경우 &lt;div&gt;reset&lt;/div&gt;의 값은 0이 되며,
AND 게이트와 OR 게이트는 0을 출력하도록 변하기 때문에(&lt;code&gt;1 AND 0 = 0&lt;/code&gt;; &lt;code&gt;0 OR 0 = 0&lt;/code&gt;)
최종적으로 out은 0이라는 값을 출력하게 된다.
이후 reset의 값이 0으로 돌아가더라도 피드백으로 인하여&lt;br/&gt;
AND 게이트와 OR 게이트는 0을 여전히 출력하게 된다(&lt;code&gt;0 AND 1 = 0&lt;/code&gt;; &lt;code&gt;0 OR 0 = 0&lt;/code&gt;).&lt;/p&gt;&lt;h2&gt;S-R 래치&lt;/h2&gt;&lt;p&gt;기본적으로 위와 같은 방식으로 우리는
회로 내에 비트 단위로 데이터를 자유롭게 저장할 수 있다.
그리고 이러한 논리는 다양한 방식으로 구현될 수 있는데,
그 중 가장 보편적으로 사용되는 방법이 바로 &lt;strong&gt;S-R 래치(set-reset latch)&lt;/strong&gt;라는 구조다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:372px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/7b643fcaceb7129332dd47c0b700ef88/98b6e/s-r-latch.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:83.1081081081081%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+ElEQVQ4y3VUR8/qMBDM//8Z3BAXTnQBB4QA0Xvvoogqep+nWWnz8oWw0mISx+PZmbUNAPh8PnCK5XKJZrOJTqcjud1uzTldYx2Zhr44HA5YLBa43W643+94PB7I5XLYbDbY7XYy1ut1lEolE/T9fuP1eplgAsiXjEqlgmg0in6/j2q1inK5jEQi8cV6Mpmg1WrhV5gMyYhpjVqtJiyYBNLNw+EwstmsMI7H4yIF5+fzOQy7htb/ZM1nbkQNdS4UCgkgK3G5XDgej8J6NBr9Z8hRGVCzfD6PTCbzVdJsNhPmGr1e72/J1gcFHI/HKBaLkjSLSVPoOLXVYKlqEteKKVZAZXu9XtFoNMQkn88nbLvdLlarFS6Xi2kcwbSVTJftJdl7cr/fi17BYFAyEAhgOBxKezmtcWRI+tSGQOl0WjSjg2x06svS6TCrYDU/GaqGdIsfJ5NJWdhutwWEwHSbQYbcoFAo/CFjWNEVkFqlUilhaA8CDgaDL5dNU5zOMSfP57OYoX1IlhqRSETYshu8Xq85T20NdfV0OklaN2DZfKaz1uPm9/ulA6ivx+ORO4DMeVoEkKW53W7EYjEph0BkQA3tsV6v5QT9PMv84Y1BkTk+n08pl89kwIZmr9Hd6XQqm/MbXfd12/y6CxkE0PuQJVMjp3vQ2jb/AC91CV/1QJ8QAAAAAElFTkSuQmCC&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;S-R 래치&quot; title=&quot;S-R 래치&quot; src=&quot;/static/7b643fcaceb7129332dd47c0b700ef88/98b6e/s-r-latch.png&quot; srcSet=&quot;/static/7b643fcaceb7129332dd47c0b700ef88/12f09/s-r-latch.png 148w,/static/7b643fcaceb7129332dd47c0b700ef88/e4a3f/s-r-latch.png 295w,/static/7b643fcaceb7129332dd47c0b700ef88/98b6e/s-r-latch.png 372w&quot; sizes=&quot;(max-width: 372px) 100vw, 372px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;해당 회로에서 사용되는 NAND 게이트&lt;div num=&quot;1&quot;&gt;&lt;/div&gt;의 경우
두 가지 입력값이 모두 1인 경우에만 출력값이 0이 되며,
그 외에는 출력값이 1이 된다.
처음 보면 낯설 수도 있겠지만 기본적인 원리는 앞서 다룬 래치와 크게 다르지 않다.&lt;/p&gt;&lt;p&gt;입력값 set과 reset이 각각 1과 0일 때, &lt;div&gt;set&lt;/div&gt;과 &lt;div&gt;reset&lt;/div&gt;은
각각 0과 1이 된다.
S 게이트는 입력값 중 하나가 0이므로 무조건 출력값이 1이 되는데(&lt;code&gt;0 NAND ? = NOT (0 AND ?) = NOT 0 = 1&lt;/code&gt;),
이에 따라 출력값 Q는 1의 값을 지니게 된다.
한편 R 게이트의 경우 입력값으로 1과 1이 들어오게 되므로 출력값이 0이 되고, &lt;div&gt;Q&lt;/div&gt;의 값은 0이 된다.
그리고 S 게이트의 또 다른 입력값(&lt;div&gt;set&lt;/div&gt; 이외의 값)으로는 0이 들어오게 되면서
결과적으로 S 게이트는 &lt;code&gt;0 NAND 0 = 1&lt;/code&gt;, R 게이트는 &lt;code&gt;1 NAND 1 = 0&lt;/code&gt;의 값을 출력하게 된다.&lt;/p&gt;&lt;p&gt;이후 set의 값이 0으로 돌아가게 되면 &lt;div&gt;set&lt;/div&gt;의 값은 1로 변한다.
이에 따라 S 게이트의 입력값은 0과 0에서 1과 0로 변하게 되지만
그 출력값은 여전히 1로 유지되기 때문에(&lt;code&gt;1 NAND 0 = 1&lt;/code&gt;)
Q와 &lt;div&gt;Q&lt;/div&gt;의 값은 그대로 1과 0으로 유지됨을 알 수 있다.&lt;/p&gt;&lt;p&gt;그리고 S-R 래치는 기본적으로 대칭적인 설계를 지니고 있다.
때문에 set과 reset에 0과 1을 넣었을 때 위와 동일한 방식으로 동작하여
Q와 &lt;div&gt;Q&lt;/div&gt;이 0과 1이라는 값을 출력할 것임을 쉽게 예상할 수 있을 것이다.&lt;/p&gt;&lt;p&gt;결과적으로 S-R 래치는 대부분의 경우 set과 reset이 모두 0인 상태로 존재하며,
이전 입력값에 따라 정해진 Q와 &lt;div&gt;Q&lt;/div&gt;의 값을 그대로 출력값으로 유지하게 된다.
비트 단위로 데이터를 저장하는 것이 핵심 기능인 회로에 부합한다고 볼 수 있다.&lt;/p&gt;&lt;p&gt;한편 set과 reset이 모두 1인 경우에는 어떠할까?
이 경우 &lt;div&gt;set&lt;/div&gt;과 &lt;div&gt;reset&lt;/div&gt;은 0과 0라는 입력값으로 회로에 들어오게 된다.
NAND의 입력값에 0이 존재하므로 출력값은 무조건 1이 되며,
이에 따라 Q와 &lt;div&gt;Q&lt;/div&gt; 모두 1이라는 값을 지니게 되는데, &lt;div&gt;Q&lt;/div&gt;은
Q를 반전시킨 값을 지녀야 하므로 논리적으로 옳지 않은 결과라고 볼 수 있다.
애초에 set과 reset이 1이라는 뜻은 데이터를 1로 설정하면서 동시에 0으로 초기화하라는
모순되는 지시를 넣은 것으로 볼 수 있다. 때문에 S-R 래치를 사용할 때
이러한 입력값이 존재할 수 없도록 유의해야 한다.&lt;/p&gt;&lt;h2&gt;안정성 문제&lt;/h2&gt;&lt;p&gt;비트 단위에서 생각했을 때 위와 같은 구조는 논리적으로 틀리지 않았다.
그런데 한 가지 고려해야 할 점은 회로란 철저히
물리적인 특성을 지닌 기계라는 점이다.&lt;/p&gt;&lt;h3&gt;데이터 변화 시점&lt;/h3&gt;&lt;p&gt;우선 현재 회로에서는 1이라는 데이터를 저장할 때에만 set에 1이라는 값이 들어오고,
0으로 데이터를 되돌릴 때에만 reset에 1이라는 값이 들어오는 것을 가정하고 있다.
그렇다면 혹시라도 데이터를 변경할 생각이 없음에도
순간적으로 set이나 reset에 1이라는 입력값이 들어온다면 어떻게 될까?
래치는 이를 문제라고 인식하지 못하고 당연히 1이나 0으로 출력값을 설정할 것이다.&lt;/p&gt;&lt;p&gt;이러한 가능성을 최소화하기 위해서는
저장하려는 데이터에 대한 입력값만이 아니라,
해당 정보를 사용하여 실제로 &lt;strong&gt;회로에 데이터를 저장하라고 명령을 내리는 입력값&lt;/strong&gt;도
함께 받아들이는 것이 가장 확실한 안전장치라고 볼 수 있다.
즉, 회로의 출력값을 변경하라는 명령이 들어오지 않는 동안에는
저장하려는 입력값이 0이 되든 1이 되든 회로에 아무런 영향도 미치지 못하게 하는 것이다.&lt;/p&gt;&lt;h3&gt;전파지연&lt;/h3&gt;&lt;p&gt;한편 입력값들에 부합하는 연산 결과가
게이트들을 지나 출력값으로 나올 때까지는 당연히 시간이 걸리며,
우리는 이를 &lt;strong&gt;전파지연(propagation delay)&lt;/strong&gt;이라고 부른다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/76fc055ece1232dbfcb614cee4de492f/18c13/propagation-delay.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:31.756756756756754%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA+klEQVQY022QSWvDQAyF/f//RkNj55zk7nMcu2BIfUiNwfuO992vSGAT2gjEY+aNPkkjrOuKd0nRdR3iOIbruqx5niPLMlY627a936Vpyir8hbxG27YwTRNhFP3z5nmGZVnwfZ/BlGEYQqiqCmVZgpS6bAbBmqbBsiyIogiGYcDzPJ52gziOg2ma9iZUz0B6QCuQUkEQBDuwrmuodxUn6YS+7znJK4oC4lGErusMo3OSJBCogDoRhC5fgzyaSpZlHD4OuF6ucGyHPQKLn0dIooTL+cwTE0PAm9j+cxgGjOPIUyu3G+6Kgp/nk1ejRl+aBk1V8f148Oq07S8El8L2WsvHjgAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;전파지연&quot; title=&quot;전파지연&quot; src=&quot;/static/76fc055ece1232dbfcb614cee4de492f/fcda8/propagation-delay.png&quot; srcSet=&quot;/static/76fc055ece1232dbfcb614cee4de492f/12f09/propagation-delay.png 148w,/static/76fc055ece1232dbfcb614cee4de492f/e4a3f/propagation-delay.png 295w,/static/76fc055ece1232dbfcb614cee4de492f/fcda8/propagation-delay.png 590w,/static/76fc055ece1232dbfcb614cee4de492f/efc66/propagation-delay.png 885w,/static/76fc055ece1232dbfcb614cee4de492f/18c13/propagation-delay.png 1005w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;위의 그림을 보면 알 수 있겠지만
B라는 입력값이 변화했을 때 NOT 게이트의 출력값인 C가 변하는 데에는 시간이 걸리며,
다시 C를 입력값으로 받아 생성되는 D라는 출력값이 변하는 데에도 시간이 걸린다.
문제는 이 시간이 확실하게 고정된 값이 아니라 회로의 구성 등을 토대로
계산된 통계적인 예측값이라는 점이다.
이로 인해 회로에 입력값이 변경되었을 때
위의 회색 구간처럼 실제 출력값을 &lt;strong&gt;예측할 수 없는 구간&lt;/strong&gt;이 생겨나게 된다.&lt;/p&gt;&lt;p&gt;이러한 구간이 구체적으로 어떠한 문제를 발생시킬 수 있을까?
예를 들어 메모리에 &lt;code&gt;1&lt;/code&gt;과 &lt;code&gt;1&lt;/code&gt;을 저장하고
해당 비트 데이터에 대해 덧셈 연산을 수행하도록 지시를 내린다고 생각해보자.
만일 두 비트 데이터 중 하나가 아직 &lt;code&gt;0&lt;/code&gt;에서 &lt;code&gt;1&lt;/code&gt;로 변하기 전에
연산이 실행된다면 &lt;code&gt;1 + 1 = 2&lt;/code&gt; 대신 &lt;code&gt;1 + 0 = 1&lt;/code&gt;이라는 결과가 출력될 것이다.&lt;/p&gt;&lt;p&gt;때문에 회로가 안정적으로 동작하기 위해서는
하나의 작업을 수행했을 때마다 가급적 최악의 경우를 가정하고
&lt;strong&gt;예상되는 지연 시간의 최댓값만큼 다음 연산의 수행을 지연&lt;/strong&gt;해야 한다.&lt;/p&gt;&lt;p&gt;바로 이러한 두 가지 목적을 달성하기 위해 일반적인 메모리 회로에서는
&lt;strong&gt;클록(clock)&lt;/strong&gt;이라는 개념을 활용한다.&lt;/p&gt;&lt;h2&gt;클록&lt;/h2&gt;&lt;p&gt;클록이란 무엇인가.
이름만 보면 회로 내에서 시계와 같은 기능을 하는 부품이라고 생각할 수 있겠지만
정확히는 &lt;strong&gt;시간의 경과를 알려주는 데이터 입력값&lt;/strong&gt; 자체를 의미한다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:359px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/701fcfc84d754e0048fda11b68711098/f5eb6/oscillator.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:44.5945945945946%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABUElEQVQoz41SXYuCUBD1//+D/kMvPUYQRZqoUKlRlIRlVg+aGaFlX2c5A1d2oWV3YJj7Mffcc2ZG2263mE6nWCwWmM1mmM/ndeR5WZagvd9v/Me0yWSCNE1xPp9RVRWKohC/3+8IggD7/V4SX69XDcr4m2tkFscx2u02brdb/Zi22+1qQGV/MRVAPiSb0WgkTJUlSYIsy2TNz/I8l/X1epU9P6YaRnWmeZ6H8XgsLGm2bcMwDERRBF3XZU1Wz+ezBhwMBjBNU950u11sNhvZU412PB7R7/exWq0keTgcotlswnEcdDodKQVZXC4XqTVBSMJ1Xfmc+16vJ40UyUoa0ZnErn8ySucd88j0dDphvV7j8XggDMO6/poqfqvVwuFw+NFFyqR/bwTrxWmg845AHC0y5JkAUo4CUx3+NBK8Wy6X8H1fZpSR82pZFhqNhij9AlUVpVknaddWAAAAAElFTkSuQmCC&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;발진자&quot; title=&quot;발진자&quot; src=&quot;/static/701fcfc84d754e0048fda11b68711098/f5eb6/oscillator.png&quot; srcSet=&quot;/static/701fcfc84d754e0048fda11b68711098/12f09/oscillator.png 148w,/static/701fcfc84d754e0048fda11b68711098/e4a3f/oscillator.png 295w,/static/701fcfc84d754e0048fda11b68711098/f5eb6/oscillator.png 359w&quot; sizes=&quot;(max-width: 359px) 100vw, 359px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;주기적으로 0과 1 사이의 출력을 오가는 회로 내의 부품을 발진자(oscillator)라고 하는데,
이러한 부품의 출력값을
&lt;strong&gt;입력값으로 받음으로써 주기적으로 값이 1이 되었을 때에만 특정 작업을 반복하여 수행하도록 설정&lt;/strong&gt;할 수 있다.
그리고 이렇게 사용되는 입력값이 바로 클록(clock)이다.
물론 위와 같이 NOT 게이트를 사용하는 경우 다시 전파 지연이라는 문제로 인해
0이 되고 1이 되는 시점이 불확실해진다.
때문에 실제로는 크리스탈과 같이 별도의 부품을 활용하여
안정적이고 적은 비용으로 발전기를 만들어내고, 이를 통해 클록이라는 자극을 구현한다.&lt;/p&gt;&lt;p&gt;우리는 이제 이 클록을 래치의 입력값으로 받아 적절하게 사용함으로써
위에서 이야기한 문제점들을 해결할 수 있다.
드디어 우리는 이 게시물의 핵심인 D 플립플롭에 대해 이야기할 준비가 끝났다.&lt;/p&gt;&lt;h2&gt;플립플롭&lt;/h2&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/828c51e178ab2af439055368e686c483/1cfc2/d-flip-flop.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:72.97297297297297%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABaklEQVQ4y5WU2YrCQBRE/f8fUxREVHxwiQtuiUvivlvDudAhE3vCeKFJTNrqU3W7U1Km3u93Op7Ppy6XizabjbbbrT1zc4qqlBekbrebwjDUfD7XarXS/X5Xv9/X4XD4tfC/Bc/ns06nkxaLhdbrtR6PhwaDgZbL5YdgXtgriNX9fq8kSVSpVFStVk0Ycl882d+FhNPpVKPRyOwPh8OUMo5j+f6XEubxIYQOKoSpTqejcrlslNfrVd1u195z7yXM4tME8pvNZnalIVAiCh0L8ozBbvgQdEKv18u6ikir1TLLkBIBxTvyrNfrtgNcpoWWEcVGFEXq9XrWHAbFAlBjdTwe25X52QZ5LbMylM1m06xikeZgmXts4iAIAh2Px78tZzPEXq1Ws65CDFGj0Uj3psvOa9l3/Kjdbmd5ITSZTNKO++YW7kNyoaByew8y7H99UvI5ug632237SHx9lt1EcuNLQ2ch9G0Rn+APpO+L3dioMPgAAAAASUVORK5CYII=&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;D 플립플롭&quot; title=&quot;D 플립플롭&quot; src=&quot;/static/828c51e178ab2af439055368e686c483/fcda8/d-flip-flop.png&quot; srcSet=&quot;/static/828c51e178ab2af439055368e686c483/12f09/d-flip-flop.png 148w,/static/828c51e178ab2af439055368e686c483/e4a3f/d-flip-flop.png 295w,/static/828c51e178ab2af439055368e686c483/fcda8/d-flip-flop.png 590w,/static/828c51e178ab2af439055368e686c483/efc66/d-flip-flop.png 885w,/static/828c51e178ab2af439055368e686c483/1cfc2/d-flip-flop.png 900w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;핵심만 말하자면 플립플롭은 비트 단위로 데이터를 저장하는 회로 구조이다.
그 중에서 특히 D 플립플롭이 메모리 회로를 구성하기 위해 흔하게 사용되며
위와 같은 구조를 지닌다.
그러나 엄밀히 말하자면 플립플롭이란
&lt;strong&gt;에지에 의해 데이터 변화가 촉발되는 래치(edge-triggered latch)&lt;/strong&gt;이며,
D 플립플롭은 &lt;strong&gt;양의 에지에 의해 변화가 촉발되는(positive edge-triggered) 플립플롭&lt;/strong&gt;을
의미한다.
대체 이게 무슨 의미일까?
위의 구조를 한 번 자세히 들여다봐보자.&lt;/p&gt;&lt;p&gt;우선 D 플립플롭의 우측 부분만 보았을 때 위에서 다룬
S-R 래치와 동일함을 알 수 있다.
Q와 &lt;div&gt;Q&lt;/div&gt;는 플립플롭의 최종적인 출력값으로 사용되며,
clock과 D라는 입력값을 토대로
정해지는 &lt;div&gt;S&lt;/div&gt;와 &lt;div&gt;R&lt;/div&gt;라는 데이터는
S-R 래치의 두 입력값 &lt;div&gt;set&lt;/div&gt;와 &lt;div&gt;reset&lt;/div&gt;에 대응된다.
그렇다면 clock과 D라는 입력값의 변화와 그 조합에 따라 S와 R의 값이
어떻게 정해지는지만 파악하면 이 회로를 완전히 파악할 수 있다.&lt;/p&gt;&lt;h3&gt;클록이 변할 때 D의 값이 저장된다&lt;/h3&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/67b2e6e9336cfced888421b1b4cc68ee/2d2d6/edge-triggering-process.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:41.21621621621622%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABEklEQVQoz1WSV47DMAxEff/r+TPuDe69NwaPgYBdAkJEajgzZGy97yvzPP87x3HIuq4yjqNM0yQmqBVFIfu+a/2+b8nzXO/LsmhuPc+jyefzEd/3leS6LgWa3ASNVVVJEATSNI0SIEBeluWPECCu6rqWLMskjmN1CIBmiE2A6/teiTFA3rat1hCHw8INjSjyCBnEphFVE+AMFueM7nme1oZhEKa1aEjTVA93CMMwVBBi5AAJHDAeuwTLqmzbVnGwHB0ZdkZjTNQB4pL9cEz8dYSB8zzFdV29d10n27b9CHGAMg+oE0mSqFPzLxuXCDqOo3iCCdh7FEUqqIQw08gvqlgnh5wGE3xi7BkM74gYHFNS/wK26GSsLNOFcgAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;에지에 따른 변화&quot; title=&quot;에지에 따른 변화&quot; src=&quot;/static/67b2e6e9336cfced888421b1b4cc68ee/fcda8/edge-triggering-process.png&quot; srcSet=&quot;/static/67b2e6e9336cfced888421b1b4cc68ee/12f09/edge-triggering-process.png 148w,/static/67b2e6e9336cfced888421b1b4cc68ee/e4a3f/edge-triggering-process.png 295w,/static/67b2e6e9336cfced888421b1b4cc68ee/fcda8/edge-triggering-process.png 590w,/static/67b2e6e9336cfced888421b1b4cc68ee/efc66/edge-triggering-process.png 885w,/static/67b2e6e9336cfced888421b1b4cc68ee/c83ae/edge-triggering-process.png 1180w,/static/67b2e6e9336cfced888421b1b4cc68ee/2d2d6/edge-triggering-process.png 1205w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;위의 회로도를 한번 봐보자. 굵은 색은 1에 해당되는 값의 전파가 흐르고 있음을 의미한다.&lt;/p&gt;&lt;p&gt;좌측의 두 회로도를 보면 D의 값이 1로 고정되었을 때
clock이 0에서 1로 변하자 S의 값이 0에서 1로 변함을 알 수 있다(&lt;div&gt;S&lt;/div&gt;은 1에서 0으로 변화).
이는 플립플롭의 출력값이 1로 설정되었음을 의미한다.&lt;/p&gt;&lt;p&gt;우측의 두 회로도의 경우 D의 값이 0으로 고정되었을 때
clock이 0에서 1로 변하자 R의 값이 0에서 1로 변함을 알 수 있다(&lt;div&gt;R&lt;/div&gt;은 1에서 0으로 변화).
이는 출력하는 값이 0으로 설정되었음을 의미한다.&lt;/p&gt;&lt;p&gt;그렇다. &lt;strong&gt;D라는 입력값은 회로에 저장하고 싶은 데이터를 의미한다.&lt;/strong&gt;
그리고 클록이 0에서 1로 변하는 순간이 바로 이 D라는 입력값을 회로에 저장하라는 신호이다.
이러한 신호를 우리는 &lt;strong&gt;에지(edge)&lt;/strong&gt;라고 부르며,
이것이 바로 위에서 우리가 희망하던 &lt;strong&gt;회로에 데이터를 저장하라고 명령을 내리는 입력값&lt;/strong&gt;이라고 볼 수 있다.&lt;/p&gt;&lt;p&gt;이제야 우리는 위에서 언급한 &lt;strong&gt;에지에 의해 데이터 변화가 촉발&lt;/strong&gt;된다는
플립플롭의 정의를 이해할 수 있게 되었다.
특히 D 플립플롭은 &lt;em&gt;양의 에지&lt;/em&gt;에 의해 변화가 촉발된다고 하였는데,
그 의미가 바로 클록이 0에서 1로 변화할 때 D의 값을 저장한다는 의미이다.
만약 클록이 1에서 0으로 변할 때 변화가 촉발될 경우
&lt;em&gt;음의 에지&lt;/em&gt;에 의해 변화가 촉발(negative edge-triggered)된다고 정의되었을 것이다.&lt;/p&gt;&lt;h3&gt;클록이 일정할 때 D는 영향력이 없다&lt;/h3&gt;&lt;p&gt;이번에는 클록이 고정되어있을 때 D의 변화가 출력값에 미치는 영향에 대해 알아보자.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/545905e6ff2ef894d2f911879ce9b420/2e694/d-powerless.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:34.45945945945946%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA8klEQVQoz02Rh6oFMQhE8//fuLCV7Y3t3csZyOMJkmTUcTRu2zZb19Xu+zaMc5omYdd16Zzn2Y7jUPx9X72XZbF935XPyZuYa9vW0jQVgFFY17UwiMdx1J087Hkea5rGsiyzvu/tPE8rikKOAEe3siwFYCgisaoqy/PchmGwrussSRKR4cQgBUcIdxwxDjJIkIuhKIqivzWEYagGfiUUEfcr8MTf9+nt6AaAEowRIGFEdsNoqGd8mlIYx7FU0hycOE2lECLGYXRvYBSRzF6IQ+CnIB4EgXaNct+Uu4P1/y9j/udRC86ewPxY1HiMnZKLE/8Bwa0ZZ+gBQkcAAAAASUVORK5CYII=&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;D의 무력함&quot; title=&quot;D의 무력함&quot; src=&quot;/static/545905e6ff2ef894d2f911879ce9b420/fcda8/d-powerless.png&quot; srcSet=&quot;/static/545905e6ff2ef894d2f911879ce9b420/12f09/d-powerless.png 148w,/static/545905e6ff2ef894d2f911879ce9b420/e4a3f/d-powerless.png 295w,/static/545905e6ff2ef894d2f911879ce9b420/fcda8/d-powerless.png 590w,/static/545905e6ff2ef894d2f911879ce9b420/efc66/d-powerless.png 885w,/static/545905e6ff2ef894d2f911879ce9b420/2e694/d-powerless.png 1048w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;좌측의 회로도는 클록이 0으로 고정된 경우를 나타낸다.
이때 클록의 값은 각각 &lt;div&gt;S&lt;/div&gt;와 &lt;div&gt;R&lt;/div&gt;의 값을 결정하는
두 NAND 게이트의 입력값으로 사용된다는 점에 유의하자.
NAND 게이트는 입력값이 모두 1인 경우에만 0을 출력하기 때문에
클록값이 0이라면 D의 값이 어떻든지와는 무관하게
언제나 1이라는 값을 일관되게 출력할 것임을 쉽게 예상할 수 있다.&lt;/p&gt;&lt;p&gt;중앙에 있는 두 회로도의 경우 클록이 1이고, &lt;div&gt;S&lt;/div&gt;와 &lt;div&gt;R&lt;/div&gt;의 값이
1과 0일 때 D가 변화하는 경우를 다루고 있다.
이 경우 &lt;div&gt;S&lt;/div&gt;와 &lt;div&gt;R&lt;/div&gt;의 값은 그대로 1과 0으로 유지된다.
이는 D가 0인 상태로 클록이 1이 되었을 때 촉발된 &lt;em&gt;데이터를 0으로 설정하라&lt;/em&gt;는 지시는
이후 D의 값이 변화하더라도 그대로 수행될 것임을 알 수 있다.&lt;/p&gt;&lt;p&gt;마지막으로 우측에 있는 두 회로도의 경우 클록이 1이고, &lt;div&gt;S&lt;/div&gt;와 &lt;div&gt;R&lt;/div&gt;의 값이
0과 1일 때 D가 변화하는 경우를 다루고 있다.
이 경우에도 마찬가지로 &lt;div&gt;S&lt;/div&gt;와 &lt;div&gt;R&lt;/div&gt;의 값은 그대로 0과 1으로 유지된다.&lt;/p&gt;&lt;p&gt;이를 통해 우리는 클록이 0에서 1로 변하는 시점(에지)에서의 D의 값만이
회로에 변화를 일으킬 뿐,
&lt;strong&gt;D의 변화 자체는 아무런 영향도 미치지 못함&lt;/strong&gt;을 알 수 있다.
이는 클록이 0과 1 사이를 오가는 주기를 적절하게 설정함으로써
회로에 변화가 일어나는 시점을 온전히 통제할 수 있음을 의미한다.
이에 따라 우리는 위에서 이야기한 &lt;strong&gt;예상되는 지연 시간의 최댓값만큼 다음 연산의 수행을 지연&lt;/strong&gt;한다는
목적을 이룰 수 있게 되었다.&lt;/p&gt;&lt;h3&gt;클록 에지 시점에 D는 고정되어야 한다&lt;/h3&gt;&lt;p&gt;다만, 오해하면 안 되는 점이 한 가지 있다.
바로 클록 에지가 발생하는 시점에는 D의 값이 마음대로 변해서는 안 된다는 점이다.
클록의 값이 0에서 1로 변화하는 시점에 D의 값이 안정적으로 유지되어야만
의도한 방식으로 회로의 출력값을 변화시킬 수 있다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/a506178f665aa746ffad61322470e3b4/42d54/setup-and-hold-time.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:22.972972972972975%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABCklEQVQY0z2O3Y6CMBSEef/3WUlW/EGglcINSAGlXtkCATQahdvZ9CTrxZeZ007OHOf5fOKmNbqug9aaMG1Lc9u2X/q+pzfLvzem/Wa7vscwDHCyLEMQRYhFgt+1h7W3QRCGEGmKIIyQJCmiiCEWAr5/wG7vI2QMe/+AleviZ+Vis93RDsaPcGzb6/XC5/Mh5nnGsiyk7/cbyzzjfr/DGIPH44FpmjCOI8ZhIG//LNbbXU5+OlHrMRaIGMfa86h5s92CxzH4MaZrpCxRFBJpkiLPTzifL8jyHIxzMMYhRIJClnC0NqiqGup6RaMUBau6JrWzUlfySik0jUJVVaSXpiEvyxJSShRSUuYPU81h1Q+xWNYAAAAASUVORK5CYII=&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;셋업타임과 홀드타임&quot; title=&quot;셋업타임과 홀드타임&quot; src=&quot;/static/a506178f665aa746ffad61322470e3b4/fcda8/setup-and-hold-time.png&quot; srcSet=&quot;/static/a506178f665aa746ffad61322470e3b4/12f09/setup-and-hold-time.png 148w,/static/a506178f665aa746ffad61322470e3b4/e4a3f/setup-and-hold-time.png 295w,/static/a506178f665aa746ffad61322470e3b4/fcda8/setup-and-hold-time.png 590w,/static/a506178f665aa746ffad61322470e3b4/42d54/setup-and-hold-time.png 858w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;위의 그림을 통해 이에 대해 자세히 알 수 있다.
CK의 값이 0에서 1로 변화하는 시점을 기준으로 그 직전과 직후에 D의 값이
안정적으로 유지되어야만 하는 기간을 각각 셋업타임과 홀드타임이라고 불린다.
이 기간 동안 D 값이 유지되어야 이를 제대로 사용하여 NAND 게이트들이 동작할 수 있다.
그리고 NAND 게이트들의 출력값이 변하고 Q와 &lt;div&gt;Q&lt;/div&gt;의 값이
최종적으로 결정될 때까지의 기간이 바로 그동안 지겹도록 이야기한 전파 지연의 기간이다.&lt;/p&gt;&lt;hr/&gt;&lt;div&gt;참고문서&lt;/div&gt;&lt;ul&gt;&lt;li&gt;컴퓨터 과학 총론: &lt;a href=&quot;https://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788993712629&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;&lt;li&gt;한 권으로 읽는 컴퓨터 구조와 프로그래밍: &lt;a href=&quot;https://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9791189909284&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;div num=&quot;1&quot;&gt;&lt;p&gt;NAND 게이트의 경우 이전 게시글들에서 설명하지 않은 개념이지만
그 명칭이나 회로도만 보더라도 그 기능을 어느 정도 유추할 수 있을 것이다.
NOT 게이트의 세모 부분은 입력값을 그대로 반환한다는 의미이며,
출력부의 작은 동그라미는 출력값을 반전시킨다는 의미이다.
그리고 NAND 게이트는 기본적으로 AND 게이트의 출력부에
바로 이 동그라미가 추가된 구조라고 볼 수 있다.
때문에 NAND 게이트는 일반적인 &lt;strong&gt;AND 연산을 수행한 이후,&lt;/strong&gt;
&lt;strong&gt;그 결과에 대해 NOT 연산을 수행한다&lt;/strong&gt;는 의미를 지닌다.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[아날로그에서 디지털로: 회로의 기초]]></title><description><![CDATA[회로란 안정성을 위해 현실에 존재하는 아날로그적인 자극을 디지털적인 동작으로 바꿔주는 도구라고 볼 수 있다. 이산적인 데이터를 일관된 논리에 따라 적절하게 활용하면 매번 동일한 입력값에 대해 동일한 출력값을 안정적으로 도출해낼 수 있게 된다.]]></description><link>https://bugoverdose.github.io/computer-science/analog-and-digital/</link><guid isPermaLink="false">https://bugoverdose.github.io/computer-science/analog-and-digital/</guid><pubDate>Mon, 10 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;아날로그(analog)와 디지털(digital)의 차이는 정확히 어디에 있을까?
일반적으로 우리는 오래된 기술을 의미하기 위해 아날로그라는 표현을,
동작하는 데 전기를 필요로 하는 기계에 대해서는 디지털이라는 표현을 사용한다.
현실에서 이러한 용법은 틀리지 않는 경우가 일반적이지만,
이는 결과론일뿐 해당 용어의 정의에 부합한다고 보기는 어렵다.
오늘은 해당 용어를
중심으로 &lt;strong&gt;&lt;div to=&quot;/computer-science/bit-and-logic-operation&quot;&gt;지난 게시글&lt;/div&gt;&lt;/strong&gt;에서
언급한 회로(circuit)에 대해 조금만 더 이야기해보고자 한다.&lt;/p&gt;&lt;h2&gt;아날로그와 디지털의 정의&lt;/h2&gt;&lt;p&gt;결론부터 말하자면 아날로그와 디지털은 다루는 데이터의 성격에 대한 이야기이다.
간단히 말해
&lt;strong&gt;아날로그는 연속적인 데이터를, 디지털은 이산적인 데이터를 다룬다는 의미다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;간단한 예를 들어보자,
30cm 자가 있을 때 우리는 cm 단위로만 길이를 측정하지 않는다.
눈금 사이의 값을 토대로 우리는 대상의 길이를
0.5cm, 0.1cm, 0.15cm 정도라고 유추할 수 있다.
이는 자의 0cm와 1cm 사이에 소수 값들이 무한하게 존재하고 있기 때문이다.
그리고 세상의 존재하는 모든 물건들의 높이, 넓이 등은 0.00001cm보다도 더
작은 단위로 측정될 수 있는데,
바로 이러한 측면에서 길이란 &lt;strong&gt;연속적인 데이터&lt;/strong&gt;라고 볼 수 있다.
현실에 존재하는 모든 물질이 지닌 길이, 부피, 무게와 같은 성질들은
이처럼 연속적인 데이터로 표현될 수 있다.&lt;/p&gt;&lt;p&gt;그렇다면 이산적인 데이터란 무엇일까?
간단히 말해 &lt;strong&gt;정수만을 다룬다&lt;/strong&gt;는 의미이다.
0과 1 사이에 다른 값이 존재하지 않는다고 간주하는 것이 바로 이산적인 데이터의 핵심이다.
그렇다. 연속적인 데이터에 비해 이산적인 데이터는
&lt;strong&gt;다루는 값의 범위가 실수에서 정수로 줄어든 것에 불과하다&lt;/strong&gt;는 것이다.&lt;/p&gt;&lt;p&gt;&lt;em&gt;엥? 범위가 줄어들었다면 정확도가 떨어지지 않나?&lt;/em&gt;라는 의문이 드는 것이 정상일 것이다.
실제로 1.5cm를 1cm나 2cm로 표현하는 것을 정확하다고 보기는 어렵다.
그러나 디지털은 단순히 아날로그적인 방식으로 도출한 결과물을 그대로 반올림하는 것을 의미하지 않는다.&lt;/p&gt;&lt;p&gt;아날로그란 현실에 존재하는 연속적인 데이터를
있는 그대로 나타내는 것이라 볼 수 있다.
다만, 이처럼 연속적인 값을 그대로 측정할 경우
누가 언제 측정하였느냐에 따라 매번 결과가 달라질 수 있다는 문제점을 내포하고 있다.
이 때문에 디지털은 0과 1 사이에 존재하는 무한한 값을 완전히 버림으로써
안정성을 추구한다고 볼 수 있다.
즉, 디지털이란 &lt;strong&gt;내부적으로 이산적인 데이터를 활용하여&lt;/strong&gt;
물리적인 현실을 나타내는 데이터를 &lt;strong&gt;안정적이고 일관되게 도출&lt;/strong&gt;해내는 것을 의미한다.&lt;/p&gt;&lt;h2&gt;회로의 필요성&lt;/h2&gt;&lt;p&gt;이산적인 데이터가 안정적이라는 것은 알겠다.
그런데 한 가지 문제가 있다.
숫자라는 것은 추상화된 개념일 뿐이며,
물리적인 실체를 지닌 도구를 만들려면 물리적인 대상과 현상을 활용해야 한다는 점이다.
그리고 현실에 존재하는 모든 물리적인 실체는
(양자역학의 세계로 들어가지 않는 한) 아날로그, 연속적이라는 특성을 지닌다.&lt;/p&gt;&lt;p&gt;바로 이 지점에서 회로가 등장한다.
회로란 전류가 흐르는 길 혹은 그러한 구조를 포괄적으로 지칭한다.
컴퓨터 자체를 하나의 회로라고 정의하는 경우도 있으며,
컴퓨터를 구성하는 개별 부품의 가장 작은 구성 단위를 회로라고 부르기도 한다.&lt;/p&gt;&lt;p&gt;그러나 회로가 지니는 의미는 본질적으로 간단하다.
회로란 안정성을 위해
&lt;strong&gt;현실에 존재하는 아날로그적인 자극을 디지털적인 동작으로 바꿔주는 도구&lt;/strong&gt;라고
볼 수 있다.
그리고 이산적인 데이터를 일관된 논리에 따라 적절하게 활용하면 우리는
매번 동일한 입력값에 대해 동일한 출력값을 안정적으로 도출해낼 수 있게 된다.&lt;/p&gt;&lt;h2&gt;전이함수&lt;/h2&gt;&lt;p&gt;그렇다면 구체적으로 어떠한 방식으로 회로가 동작하며 구성되는지를 한 번 알아보자.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/9e15258daf0af0505b88fc9d814d8723/d0cc0/transfer-function.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:48.64864864864865%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABHklEQVQoz3VSSY6EMAzk/+/hFRw5cYADIIY9kGZfPSprHEUMbckK2HG5XLFz3zfB1nWlYRhonmeapumfj+PIJ/LwoigoTVOq65ratqWu6xjHoT/bto3O86RvNgwfyn8yUq0ipRQ3EDKwZVn439Fak/hxHJxEwr5sN/V9nxnhW5iDcVmWlGUZOZ7nkeu6FASBAYNd10UfrVmGvu9ZEhTBkbMdNQDGhMwQeqDIHhkXoQsAi6KkJEl4gn3fOfc0sOWR7XFw+c2apjHNUCiAtjQGUAIQVTREAQDQAOylEeLQ601fiRtABAAqRVEUsV5P1mCCZk8d5dUdew/xelgJsMIJYMTjOKYwDNnzPDe7KC77afbwbQTb0AhAVVUxk28Ghr9SwAqTLNM+fgAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;전이함수&quot; title=&quot;전이함수&quot; src=&quot;/static/9e15258daf0af0505b88fc9d814d8723/fcda8/transfer-function.png&quot; srcSet=&quot;/static/9e15258daf0af0505b88fc9d814d8723/12f09/transfer-function.png 148w,/static/9e15258daf0af0505b88fc9d814d8723/e4a3f/transfer-function.png 295w,/static/9e15258daf0af0505b88fc9d814d8723/fcda8/transfer-function.png 590w,/static/9e15258daf0af0505b88fc9d814d8723/d0cc0/transfer-function.png 732w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;전이함수란 외부에서 들어오는 자극의 정도에 따라
데이터가 어떻게 수치화되는지에 대한 함수이다.
기본적으로 외부에서 들어오는 자극, 즉 입력값이
직선부(linear region)의 범위를 벗어나지 않을 경우
출력값은 입력값의 정도에 1대1로 대응되는 데이터로 변환된다고 볼 수 있다.
이처럼 입력값을 그대로 데이터화하는 것이 바로 아날로그적인 방식이라고 볼 수 있다.
그렇다면 어떻게 해야 디지털적인 방식으로 입력을 데이터화할 수 있을까?&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:496px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/7f8f19b3c583b94eff40ae1028566494/bb630/clipping.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:64.86486486486486%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABkElEQVQ4y41T6crCQAzs+z+SUsFfgojoJ4jF1qOt1R5e2Najx8jkc0u9wEDY7W4ym5mkGn60JElwuVxkjeMYRVEgSWI4to0oDKs4LcsyCbxer29+Pp9h2zYMw0Cj0UC73Yau62g2mxiNRtjtdvgbDtHr9bBer5GmKTQm5lmGsixRFoWsfJ12OBxgmaZUxTM+XjximExbeR6CIIDjOP8V3m63CkAZE2jH4xGe573d05hHm8/nCMNQQCvAPM8rIOXy+moF3/elUiUBnRKdTiep2LIsiVsul58B6yuDoyjCdrsVIFKnE3yxWIiGs9lM7tko5omGdUrcq+/xeFx199WoGQE3m82TVNJlVqjo1G0ymQjYJ0DXdbHf758AhTIPO50OWq0WBoOBlE/dTNNEt9uVpvCMlVI3Oh9mM6bTqchClgpcKLOb1EAlEJBzRUoEJT0y4agoJnQ2i3n1hmn1cgOf8+TKBR+h8KyC+19Nq8akLB+/Viprv9+XUeBeDXF9rL659jrMqtOky/niWJHSa8y3Cu9FHeq763Ng9gAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;클리핑&quot; title=&quot;클리핑&quot; src=&quot;/static/7f8f19b3c583b94eff40ae1028566494/bb630/clipping.png&quot; srcSet=&quot;/static/7f8f19b3c583b94eff40ae1028566494/12f09/clipping.png 148w,/static/7f8f19b3c583b94eff40ae1028566494/e4a3f/clipping.png 295w,/static/7f8f19b3c583b94eff40ae1028566494/bb630/clipping.png 496w&quot; sizes=&quot;(max-width: 496px) 100vw, 496px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;위는 곡선의 가파른 정도, 즉 게인(gain)을 최대한으로 설정했을 때의 그래프를 보여준다.
해당 그래프의 핵심은 &lt;strong&gt;입력값의 범위가 직선부를 넘어선다는 점&lt;/strong&gt;이다.
이러한 구조는 더 이상 외부 자극에 1대1로 대응되는 값을 출력하는 것을 목표로 하지 않는다.
기본적으로 모든 입력값은 기본적으로
포화(saturation)라고 불리는 상단부 영역 혹은
차단(cutoff)이라고 불리는 하단부 영역의 데이터 중 하나를 출력하게 된다.
&lt;strong&gt;바로 이 값이 개별 비트에 담기는 0 혹은 1이라는 데이터의 물리적인 형태&lt;/strong&gt;라고 볼 수 있다.&lt;/p&gt;&lt;p&gt;그리고 회로를 구성하는 모든 요소들은 전기를 입력받아
이처럼 0 혹은 1의 해당되는 데이터를 전기의 형태로 출력하고,
다시 서로로부터 해당 출력값을 입력값으로 받음으로써
&lt;em&gt;0과 1의 세계&lt;/em&gt;가 만들어지게 된다.&lt;/p&gt;&lt;h3&gt;어째서 0과 1만 다루는가&lt;/h3&gt;&lt;p&gt;사실 위의 내용을 읽으면 의문이 들어야 정상이다.
이산적인 데이터를 정수라고 설명해놓고는 왜 0과 1만을 다루는 것일까?&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/4413cefa6932a6439e1d0871c4f4d199/3fca6/possibilities.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:31.08108108108108%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA1klEQVQY002QWwqFMAxE3f/i9E9FEAVFQfGJWm3VuUwg3gbSlrSdnEnwPA/u+4a/n+eJfd9xHAecc3jfF9ZaOTP1zPq6rui6Tt7zb8CFF37oJetMNmIyWNeo6xpJkqBpGlRVhW3bECiVkBmD67rkQol9eg0SZlmGKIpQlqUQcidIoB2NMVKgID+TTCl9F9M0iVAYhojjGHmeo23bvyBnwZkty/LZUavOOhG3zmEYBrGWpimKoviSYvM8o+97masQkoo21LoS8YFaZne6YGMKjOMoTTgeP35kPdBDSLdMjQAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;가능성들&quot; title=&quot;가능성들&quot; src=&quot;/static/4413cefa6932a6439e1d0871c4f4d199/fcda8/possibilities.png&quot; srcSet=&quot;/static/4413cefa6932a6439e1d0871c4f4d199/12f09/possibilities.png 148w,/static/4413cefa6932a6439e1d0871c4f4d199/e4a3f/possibilities.png 295w,/static/4413cefa6932a6439e1d0871c4f4d199/fcda8/possibilities.png 590w,/static/4413cefa6932a6439e1d0871c4f4d199/efc66/possibilities.png 885w,/static/4413cefa6932a6439e1d0871c4f4d199/3fca6/possibilities.png 1112w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;사실 위와 같은 방법으로 3진법이나 10진법을 구현하는 것도 가능은 할 것이다.
그러나 보면 알겠지만 3진법부터는 전이함수의 중앙에 있는 범위에
값을 유지시킬 수 있어야 모든 값을 제대로 사용할 수 있게 된다.
이는 입력값을 단순히 최대 혹은 최소로 지정하는 것에 비해
안정성이 떨어진다고 볼 수 있다.&lt;/p&gt;&lt;p&gt;뿐만 아니라 두 가지 종류의 데이터만으로도
비트 단위에 대해 논리연산을 조합함으로써
보다 복잡한 연산을 구현해내는 것이 충분히 가능하다.
이에 대해서는 &lt;strong&gt;&lt;div to=&quot;/computer-science/bit-and-logic-operation&quot;&gt;지난 게시글&lt;/div&gt;&lt;/strong&gt;에서 다루었다.&lt;/p&gt;&lt;h2&gt;잡음내성과 글리치&lt;/h2&gt;&lt;p&gt;아날로그에서 디지털로 넘어온 것도,
이산적인 데이터 중에서도 오직 0과 1만을 사용하는 것도
전부 &lt;strong&gt;안정성&lt;/strong&gt;을 추구하기 때문이었다.
그러나 이것만으로는 안정성이 충분히 확보되었다고 보기 어렵다.
다양한 문제점 중 대표적인 예가 바로 잡음(noise)으로 인한 글리치(glitch) 현상이다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/4c39ee28c27426fe4dab31a8afc311dc/2b2c6/glitch.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:36.486486486486484%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA/klEQVQoz11QXW+DMAzM//9vCKTupX1oM0GRMkggQMI3ns7FaNpJkWL7fD5bbdtG67pebxgGGseRmqahIs85Rn7fd1qWhYQvPGctFUXBMeoqDIEJCGKMpLWmvu+p6zom/xjDtTFGmqaJhZ1zVJYli7Rty8OzLKMQAimICCBiraX1dAJyXdd0HAeLCZAHD+LzPHNfkiT8Z0E0AMYYdgciIA4ArCd5DIErAIOhkabpR9B7zwRMfD2flJ93Awk5NOIPXlVVPOBxv9PX7cauYQC5b63J+44UJttTsHy/L0f/wTd17roXtgFkO4HCGnILuMAKshrI0iA8uIVT/KX+9/0CLk4cN6bgjlYAAAAASUVORK5CYII=&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;글리치&quot; title=&quot;글리치&quot; src=&quot;/static/4c39ee28c27426fe4dab31a8afc311dc/fcda8/glitch.png&quot; srcSet=&quot;/static/4c39ee28c27426fe4dab31a8afc311dc/12f09/glitch.png 148w,/static/4c39ee28c27426fe4dab31a8afc311dc/e4a3f/glitch.png 295w,/static/4c39ee28c27426fe4dab31a8afc311dc/fcda8/glitch.png 590w,/static/4c39ee28c27426fe4dab31a8afc311dc/2b2c6/glitch.png 869w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;일반적으로 우리는 회로에서 입력값이 0에서 1로 변화할 때 (느리든 빠르든)
&lt;code&gt;0 -&amp;gt; 0.5 -&amp;gt; 1&lt;/code&gt;과 같은 느낌으로 매끄럽게 값이 변화한다고 생각하기 쉽다.
그러나 입력값에 잡음이 포함되는 경우도 분명 존재하며
특히 0에서 1로 느리게 변화할 때 잡음으로 인해
역치(threshold)를 여러번 오가게 될 위험이 존재한다.
이 경우 출력값은 &lt;code&gt;0 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1&lt;/code&gt;과 같이 양극단을 여러번 오가게 된다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:368px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/e71772c6848c4bb8f876f093f5d28ce7/2b727/hysteresis.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:69.5945945945946%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABz0lEQVQ4y4VU7Y6iQBDk/R/F+MMXMHtRc6iLaySuIIqAgBJPhQERxY/adF9gPVe9TirTMxTFdHeptN1usdvtEEURYiE4T+KY95Qvl0so7+8YfY4gyzIajQYmkwksy4Jt23AchzGbzeD7PqQkSfAqVFWF53nI8xy9Xu8lly4g0Q0pLpcLrtdrCdpTGIaB1WqF/X6PbrfLZ+fzmZ8XID6dbTYbSFEYMqkQKqIQrFar0DQNp9MJnU7nH+7tO8QPw/C75GeCtVqN+3g4HDAcDn9wb1fSkkQkHpKKfDAY8GqaZnnD4mO3gnRGgyx7+EyQpkrRarVQqVTKHj4S/NvDKCoP7kHRbDZ5JVsQHg2wGKKgG2ZZ9tQGNIh+v8/5dDotBZ8F95B6Qya9B5m23W6jXq/DdV38envj4RyPR8RxzEjTlMF7IbBeryFR3WRccvk9eoqC37LMQiQ6ty2EkWARMjF5k0A5gT4mvSqB+yJEme/TFP8LyZ3P8aEo0HUDrmOziU1zitFIw6c6wJ/1piQ71gy6rsO2HVjmFOPxBObEgKaNofb7SLOMjB0jCAIs/AUc2+bRU7lU5nKxQJLsvpseC/4Z0p+B7/ncM9/zECwD5ub5CV+gmSwhmIJS0wAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;이력 전이 함수&quot; title=&quot;이력 전이 함수&quot; src=&quot;/static/e71772c6848c4bb8f876f093f5d28ce7/2b727/hysteresis.png&quot; srcSet=&quot;/static/e71772c6848c4bb8f876f093f5d28ce7/12f09/hysteresis.png 148w,/static/e71772c6848c4bb8f876f093f5d28ce7/e4a3f/hysteresis.png 295w,/static/e71772c6848c4bb8f876f093f5d28ce7/2b727/hysteresis.png 368w&quot; sizes=&quot;(max-width: 368px) 100vw, 368px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;이런 글리치를 방지하는 기법 중 하나가 바로 이력 현상(hysteresis)을
사용하는 것이다.
이력 현상을 사용한다는 의미는
이력, 즉 과거에 일어난 사건을 토대로 역치를 다르게 설정한다는 의미이다.
실제로 위의 그림을 보면 0에서 1로 갈 때와 1에서 0으로 갈 때
서로 다른 전이함수를 적용된다는 것을 확인할 수 있다.&lt;/p&gt;&lt;p&gt;이처럼 추가적인 기법을 통해
잡음내성 즉, 외부의 잡음 및 간섭이 있더라도 제대로 작동할 수 있는 능력을 높일 수 있다.&lt;/p&gt;&lt;h3&gt;성능과 안정성&lt;/h3&gt;&lt;p&gt;대부분의 경우 효율성, 생산성과 같은 가치는 종종 안정성과
트레이드 오프(trade-off) 관계를 지닌다.
이 점은 하드웨어도 크게 다르지 않은 것으로 보인다.&lt;/p&gt;&lt;p&gt;하드웨어의 경우 기본적으로 안정성이 충분히 확보되었다는
전제 하에서 성능 개선을 추구한다고 볼 수 있다.
그렇다면 하드웨어는 어떠한 방식으로 성능을 개선할 수 있을까?&lt;/p&gt;&lt;p&gt;회로의 구조나 부품의 재질을 변경하지 않은 상황에서는
전기가 회로 내의 특정 부품에서 다음 부품으로 도달하는 데
걸리는 시간을 줄이는 방법이 가장 확실하다.
다만 전기 자체의 속도를 가속화하거나
전기보다 빠르면서 전기를 대체하기에 적절한 매개체는 아직 존재하지 않는다.
때문에 기업들은 꾸준히 회로의 물리적인 크기를 줄이는 것을 추구하였다.&lt;/p&gt;&lt;p&gt;그러나 문제는 회로의 소형화로 인해 성능이 개선되었을 뿐만 아니라
자연스럽게 회로의 온도가 상승한다거나,
잡음이 증가하는 등의 부작용도 함께 따라오게 되었다고 한다.
이 점을 생각했을 때 안정성에 대한 추구는
하드웨어의 발전에 있어 끝나지 않는 숙제가 아닌가 생각된다.&lt;/p&gt;&lt;h2&gt;맺으며&lt;/h2&gt;&lt;p&gt;세상에 존재하는 모든 것은 물리적인 실체를 지니고 있다.
그리고 물리적인 실체를 있는 그대로 측정할 경우 연속적인 데이터가 되며
이러한 방식으로 연속적인 데이터를 다루는 것을 보고 아날로그라고 부른다.
이에 반해 디지털이란 아날로그적인 성질을 지닌 대상을 토대로
연속적인 데이터를 이산적인 데이터로 변환하여 사용하는 것을 의미한다.&lt;/p&gt;&lt;p&gt;회로란 전기가 지닌 아날로그적인 성질을 활용하여
0과 1이라는 이산적인 데이터를 만들어내는 대표적인 디지털 도구라고 볼 수 있다.
특히 회로는 실수 대신 정수를, 정수 중에서도 0과 1만을 사용하는 등
경우의 수를 최소화함으로써 안정성을 극대화시켰다고 볼 수 있다.&lt;/p&gt;&lt;hr/&gt;&lt;div&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;컴퓨터 과학 총론: &lt;a href=&quot;https://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788993712629&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;&lt;li&gt;한 권으로 읽는 컴퓨터 구조와 프로그래밍: &lt;a href=&quot;https://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9791189909284&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[컴퓨터는 어떻게 사고하는가: 비트와 논리연산]]></title><description><![CDATA[논리 게이트란 입력 값들에 대해 일정한 불리언 연산을 수행한 결과를 출력하는 장치라고 볼 수 있다. 기본적으로 AND, OR, XOR, NOT 연산을 수행하며, 이러한 게이트가 기본 단위로 모여 더욱 복잡한 기능을 수행하는 회로를 구성하게 된다.]]></description><link>https://bugoverdose.github.io/computer-science/bit-and-logic-operation/</link><guid isPermaLink="false">https://bugoverdose.github.io/computer-science/bit-and-logic-operation/</guid><pubDate>Thu, 06 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;논리연산(logic operation)이란 기본적으로 불리언 값,
즉 참 혹은 거짓 중 하나의 값을 반환하는 연산을 의미한다.
예를 들어 자바스크립트 및 JSX 문법을 기준으로
&lt;code&gt;if (a &amp;gt; 5) return true&lt;/code&gt;의 &lt;code&gt;a &amp;gt; 5&lt;/code&gt; 부분,
&lt;code&gt;a === 1 ? &amp;quot;1이다&amp;quot; : &amp;quot;1이 아니다&amp;quot;&lt;/code&gt;의 &lt;code&gt;a === 1&lt;/code&gt; 부분,
&lt;code&gt;{!loading &amp;amp;&amp;amp; &amp;lt;Component /&amp;gt;}&lt;/code&gt;의 &lt;code&gt;!loading&lt;/code&gt; 부분과 같이
조건문에 해당되는 코드들에서는 전부 논리연산이 발생한다고 볼 수 있다.&lt;/p&gt;&lt;p&gt;그러나 논리연산은 이처럼 프로그래밍 언어에서 조건문을
수행하도록 명시적으로 지정하는 경우에만 일어난다고 볼 수 없다.
하드웨어 레벨에서 보았을 때 컴퓨터에서 일어나는 모든 처리는
본질적으로 논리연산에 기반을 두고 동작하는 것으로 보인다.&lt;/p&gt;&lt;h2&gt;컴퓨터의 개념과 기계어&lt;/h2&gt;&lt;p&gt;사실 컴퓨터라는 용어는 기계로서의 컴퓨터가 발명되기 이전부터 존재했다.
당시 컴퓨터는 계산 도구를 활용하여 숫자와 관련된 단순 계산 작업을 하는 사람들, 즉 직종을 의미하였다.
물론 현대에 와서 기계로서의 컴퓨터는 극한으로 고도화되었고,
인간 컴퓨터라는 직무를 대체하게 되었다. 그러나 과거와 마찬가지로
&lt;em&gt;상황에 따라 들어온 입력에 대해 적절한 계산을 수행하고 그 값을 출력한다&lt;/em&gt;는 점에서
그 본질은 크게 변하지 않았다고 볼 수 있다.&lt;/p&gt;&lt;p&gt;그렇다면 인간과 기계로서의 컴퓨터의 차이는 어디에 있을까?
다양한 측면이 있겠지만 필자는 가장 큰 차이가 바로 &lt;strong&gt;언어 체계&lt;/strong&gt;에 있다고 생각한다.
인간의 언어는 &lt;em&gt;텍스트&lt;/em&gt;에 기반하는데 반해
컴퓨터의 언어인 기계어(machine language)는 &lt;em&gt;비트와 논리연산&lt;/em&gt;에 기반을 두고 있다.&lt;/p&gt;&lt;h3&gt;인간의 언어: 텍스트&lt;/h3&gt;&lt;p&gt;.js, .py, .java 등 어떤 확장자를 사용하든지 간에
대부분의 경우 프로그래머가 파일에 작성하는 코드는 결국 본질적으로 텍스트에 불과하다.
각 프로그래밍 언어의 문법을 기준으로
각 텍스트는 변수의 선언, 값 할당, 제어문 등 다양한 의미를 지닐 수 있지만
이는 인간의 기준에서만 그러하다.
컴퓨터의 입장에서 이 모든 코드는 그저 텍스트일 뿐이며,
이러한 텍스트가 컴파일러에 의해 기계어로 변환되어야 비로소 컴퓨터는 이를 이해하고 실행할 수 있게 된다.&lt;/p&gt;&lt;p&gt;별도의 IDE 없이 메모장으로 만든 텍스트 파일에 자바 문법 코드를 작성하고
.java 확장자로 저장하면 컴파일러로 해당 파일의 코드를 실행할 수 있다는 점이
이러한 과정을 명시적으로 보여준다.
마찬가지로 url의 쿼리나 해쉬 값 혹은 input 태그의 값으로 특정한 형식의 텍스트를 입력하여
서버에 요청을 보냄으로써
애플리케이션에 코드를 주입하는 종류의 웹공격이 가능한 것도 바로 이 점 때문이다.&lt;/p&gt;&lt;h3&gt;기계어: 비트와 연산&lt;/h3&gt;&lt;p&gt;그렇다면 컴파일러에 의해 변환된 코드를 컴퓨터는 어떻게 이해할까?
결론부터 말하자면 &lt;strong&gt;컴퓨터의 세계는 수학의 세계&lt;/strong&gt;라고 볼 수 있다.
다만, 인간은 일반적으로 10진법을 사용하는 데 반해 컴퓨터는 2진법을 사용하여 계산을 한다.
이는 컴퓨터가 모든 데이터를 비트로써 &lt;em&gt;물리적으로&lt;/em&gt; 저장하고 다룬다는 점을 뜻한다.&lt;/p&gt;&lt;p&gt;비트(bit)란 binary digit의 줄임말로 0 혹은 1 중 하나의 값을 지니는 단위라고 이해하면 편하다.
그리고 복수의 비트를 하나의 단위로 간주할 경우
각 비트가 지니는 0 혹은 1의 &lt;em&gt;값&lt;/em&gt;과 각 비트의 &lt;em&gt;위치&lt;/em&gt;를 기준으로
각 단위는 2진법 체계의 값을 나타낼 수 있게 된다.
대표적인 예로 8비트로 구성된 하나의 바이트(byte)는 0부터 2&lt;sup&gt;8&lt;/sup&gt;-1까지의 값들을
나타낼 수 있다.&lt;/p&gt;&lt;p&gt;그렇다면 여기서 우리는 의문을 가져보아야 한다.
대체 왜 컴퓨터는 모든 것을 10진법이 아닌
2진법으로 나타내고 비트로 데이터를 다루는 것일까?
바로 이 지점에서 우리는 드디어 &lt;strong&gt;로우 레벨에서의 논리연산&lt;/strong&gt;과
&lt;strong&gt;전자회로&lt;/strong&gt;에 대한 이야기를 시작해볼 수 있다.&lt;/p&gt;&lt;h2&gt;논리연산의 본질&lt;/h2&gt;&lt;p&gt;논리연산이란 &lt;em&gt;입력된 비트들의 값&lt;/em&gt;을 토대로
&lt;em&gt;새로운 비트&lt;/em&gt;를 &lt;strong&gt;만들어내는 동작&lt;/strong&gt;이라고 볼 수 있다.
위에서 우리는 논리연산을 참 혹은 거짓 중 하나의 값을 반환하는 연산이라고 정의하였다.
그리고 비트에 담기는 1 혹은 0의 값이 바로 이 참과 거짓에 해당된다고 볼 수 있다.&lt;/p&gt;&lt;p&gt;이해를 위해 &lt;code&gt;if (a &amp;gt; 5) return true&lt;/code&gt;라는 코드를 보면
&lt;code&gt;a &amp;gt; 5&lt;/code&gt;는 a의 값이 5보다 큰 지 확인하고
그 값이 참이면 참을, 거짓이면 거짓을 반환하라는 의미이다.
즉 해당 연산의 결과로 인해
&lt;strong&gt;참 혹은 거짓이라는 값이 컴퓨터 내에 물리적으로 생성&lt;/strong&gt;되고
해당 값을 조건절로 감싸고 있는 if 문은 해당 값에 따라 조건문 내부의 코드를
실행할지 말지에 대해 결정하게 되는 것이다.
그리고 해당 코드가 실행되는 과정에서
변수 a에 담긴 값과 5라는 리터럴은 해당 위치에서 호출되었지만
컴퓨터의 메모리에서 사라지지 않으며 이후 다른 코드들에서 그대로 쓸 수 있다.&lt;/p&gt;&lt;h2&gt;불리언 연산&lt;/h2&gt;&lt;p&gt;그동안 참 혹은 거짓의 값이라고 말한 데이터는
각종 프로그래밍 언어들에서 boolean이라는 자료형으로 불린다.
해당 명칭은 영국의 수학자 George Boole에 이름에서 나온 것이며
그는 불리언 대수(Boolean algebra)라는 4가지 연산 규칙을 고안한 사람이다.&lt;/p&gt;&lt;p&gt;그는 NOT, AND, OR, XOR라는 불리언 연산자를 제안하였는데
바로 이 연산자들이 논리연산, 회로의 뼈대라고 볼 수 있다.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;NOT : 논리적 반대를 의미한다. 유일하게 단일 비트에 대해 적용된다.&lt;ul&gt;&lt;li&gt;이해: 비트의 값이 거짓인 경우 참을, 참인 경우 거짓을 출력&lt;/li&gt;&lt;li&gt;본질: 입력의 상태를 반대로 반전시킨 결과를 출력&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;AND : 둘 이상의 비트에 대해 적용되지만 프로그래밍 문법에서는 두 개의 입력값만을 받는다.&lt;ul&gt;&lt;li&gt;이해: 2비트 연산의 경우 a AND b에서 a와 b가 모두 참일 때만 참을, 그 외에는 거짓을 출력&lt;/li&gt;&lt;li&gt;본질: 입력된 모든 비트가 참일 때만 참을 출력&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;OR : 둘 이상의 비트에 대해 적용되지만 프로그래밍 문법에서는 두 개의 입력값만을 받는다.&lt;ul&gt;&lt;li&gt;이해: 2비트 연산의 경우 a OR b에서 a와 b가 모두 거짓일 때만 거짓을, 그 외에는 참을 출력&lt;/li&gt;&lt;li&gt;본질: 입력된 모든 비트 중 하나만이라도 참이면 참을 출력&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;XOR : 배타적 OR(exclusive OR)의 줄임말이다. NOT, AND, OR 연산의 조합으로 구현될 수 있다.&lt;ul&gt;&lt;li&gt;첫번째 비트와 두번째 비트가 서로 다른 경우에 참. 같은 경우 거짓을 출력&lt;/li&gt;&lt;li&gt;구현 예시: (a XOR b) == (a OR b) AND (NOT(a AND b))&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;사실 XOR 외에는 전부 일반적인 프로그래밍 언어들에 기초 문법으로
존재하는 기능들이기 때문에 개념을 이해하는 데 어려움은 없을 것이다.
그런데 앞서 언급했듯이 컴퓨터는 이처럼 프로그래밍 문법으로 명시적으로
작성하지 않은 코드에 대해서도 논리연산을 적용하여 실행한다.
그리고 위의 불리언 연산자들은 바로 이러한 연산을 이해하기 위한 핵심이라고 볼 수 있다.&lt;/p&gt;&lt;h3&gt;예제: 컴퓨터의 사칙연산&lt;/h3&gt;&lt;p&gt;누구나 쉽게 이해할 수 있도록 사칙연산 중에서도 덧셈을 예제로 준비해보았다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/b9e4c95e61067a2b1f51bb8a3875789d/d93d9/decimal-add.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:22.2972972972973%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA10lEQVQY012P22qDQBRF/f+f6ZO0tGkriUovJioZDY29QB7siLQGxwvFqas4LRK64TzsxWafcyz+5Ps+WZZxqpXrceMGjOM4M/tqySYWsz82X1xcu8RRaLzVdR1KKYQQpGlq4MTatiWKYm69NVNd3/e0TYPjr4m2O5PTeuCQl6zuQ7L9k1lsSSnJ85wkScxM5UVRMPFNGHJmL6hrRVmWSPnO+cJl6d3RKMWx+mS7e8a+dAgeH6iqCot/On1vGDR+IND6e2bJ/mAuHMdfVnzUOF7A2+uLyf0Amc0pBQ+aEJcAAAAASUVORK5CYII=&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;십진법 덧셈&quot; title=&quot;십진법 덧셈&quot; src=&quot;/static/b9e4c95e61067a2b1f51bb8a3875789d/fcda8/decimal-add.png&quot; srcSet=&quot;/static/b9e4c95e61067a2b1f51bb8a3875789d/12f09/decimal-add.png 148w,/static/b9e4c95e61067a2b1f51bb8a3875789d/e4a3f/decimal-add.png 295w,/static/b9e4c95e61067a2b1f51bb8a3875789d/fcda8/decimal-add.png 590w,/static/b9e4c95e61067a2b1f51bb8a3875789d/efc66/decimal-add.png 885w,/static/b9e4c95e61067a2b1f51bb8a3875789d/c83ae/decimal-add.png 1180w,/static/b9e4c95e61067a2b1f51bb8a3875789d/d93d9/decimal-add.png 1243w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;먼저 우리가 초등학교에서 배운 10진법에서의 덧셈 방식을 한번 봐보자.
우리는 두 수가 있을 때 각 자릿수의 값을 더한 개별 결과에 대해
해당 값이 10 이상인 경우 한 자리 위에 1의 값을 더하는 올림 작업을 수행하고,
해당 자릿수의 1의 자리 값은 그대로 해당 자릿수에 할당한다.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;1의 자리는 &lt;code&gt;5 + 0 = 5&lt;/code&gt;이므로 올림 작업을 수행하지 않고 5를 그대로 할당한다.&lt;/li&gt;&lt;li&gt;10의 자리는 &lt;code&gt;8 + 3 = 11&lt;/code&gt;이므로 올림 작업을 수행하여 일단은 1만을 할당한다.&lt;/li&gt;&lt;li&gt;100의 자리는 &lt;code&gt;1 + 1 = 2&lt;/code&gt;이지만 올림을 적용받으므로 &lt;code&gt;2 + 1 = 3&lt;/code&gt;이 된다.&lt;/li&gt;&lt;li&gt;결국 100의 자리에서는 올림 작업을 수행하지 않으므로 3을 할당하고 &lt;code&gt;315&lt;/code&gt;가 답이 된다.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;즉, 각 자릿수에 대해 개별적으로 덧셈을 적용하고
&lt;em&gt;올림 작업 수행 여부&lt;/em&gt;와 &lt;em&gt;해당 자릿수에 할당할 값을 결정&lt;/em&gt;하는 두 가지 연산이
실행된다는 점이다.
이때 올림 작업의 경우 2진법이든 10진법이든
언제나 한 자리 위에 1을 더하는 방식으로 적용되며
10진법이기 때문에 10을 기준으로 적용 여부를 결정하게 된다.&lt;/p&gt;&lt;p&gt;이러한 원리는 10진법이든, 2진법이든, 16진법이든 동일하게 적용된다. 아래 예시를 한번 봐보자.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/803f2e975a072aedbc03fc5e6c5c9bd3/27e9a/binary-add.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:22.2972972972973%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA0klEQVQY012QX0vDMBxF+/0/kU+CDzpxTsM61FC6dja2tX8TREnT2SOJTsH7di+Hk/CL+IkxhqqqcM6dJoZh5EZIrJ1+t0y17J5SWD5Df7cz+6IlzzKWZSGy1gaJF9Z1HSDf/a614TZOcG4Om5smMtUg0+fAHY8zr50mL3uUKr6FTdNQliVFUZAkSRD3vQcU+eHA2fkVbdsxDAPli2KzlazWAqNHtB55kCl3uwQhBF3XEfEv/pVT/M8uVvfY6e8Mcq+4vN54MnT99sFaPBLH29C/AJRvLr+dshN4AAAAAElFTkSuQmCC&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;이진법 덧셈&quot; title=&quot;이진법 덧셈&quot; src=&quot;/static/803f2e975a072aedbc03fc5e6c5c9bd3/fcda8/binary-add.png&quot; srcSet=&quot;/static/803f2e975a072aedbc03fc5e6c5c9bd3/12f09/binary-add.png 148w,/static/803f2e975a072aedbc03fc5e6c5c9bd3/e4a3f/binary-add.png 295w,/static/803f2e975a072aedbc03fc5e6c5c9bd3/fcda8/binary-add.png 590w,/static/803f2e975a072aedbc03fc5e6c5c9bd3/efc66/binary-add.png 885w,/static/803f2e975a072aedbc03fc5e6c5c9bd3/c83ae/binary-add.png 1180w,/static/803f2e975a072aedbc03fc5e6c5c9bd3/27e9a/binary-add.png 1253w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;위의 &lt;code&gt;11 + 11 = 110&lt;/code&gt;은 10진법을 기준으로 &lt;code&gt;3 + 3 = 6&lt;/code&gt;으로 표현되는 매우 간단한 연산이다.
10진법과의 차이점은 각 자릿수에 할당될 수 있는 값의 범위가 0과 1로 줄어들었다는 점밖에 없다.
그런데 이처럼 값의 범위가 두 가지로 줄어들었다는 점은 너무나도 큰 의미를 지닌다.
바로 &lt;strong&gt;불리언 연산을 통해 덧셈 작업을 수행&lt;/strong&gt;할 수 있는 조건이 마련되었다는 것이다.
위에서 수행한 덧셈 작업을 불리언 연산을 통해 수행하면 다음과 같다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/4b446/boolean-add.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:81.75675675675677%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACPklEQVQ4y5WTW1PaUBSF+f9/oy996EuttqVTW62iIMpFNBSRS4BwT07ugZPL1yGClUGtXTOZ7LMmZ++1zsrJ8EYkSfL43tTTuYHt+lt85qXNTxvEcfyXW/MrHB6f0Wj10zqOH/jMW1Q9RbxSZggi4KxYoaWO/k+h6wW01QEzwyT0PMLpkE7pArtZ58tBlvNihTgKH/e92DBeN+xqU959yFIoK0zGBrM7gXHZwc63+fmtRKmmrC3HL1heq0vWdRQn+DJCAtJfYis9bGOJGYA6tHC8Z0LZLHaeh9Ewn8NoBIoCMkgbhGHI58MThDC2Gz538I9YLEBVwXVBCNAGKR0EAb6MOc5X8Tx3K8DMw7QIXViYtpt+vJRLgsBHNu8JXIeVpmAwIDJNFoFP6/Yardfn49cjVLWbqt0KxXY8rq4b1O9Vard1Dr7nyJ0XqRQuqV3XyRWuKJ3mGY+m6E0V+1ue7mWf93s/qCu3r1v2/AW94RTdtBFCELgBQljYfoA0TbyGitBjVE3SaA3wPW/X8uY2bKJ/FlJCtwtxlC4HM5NypYplWf8OZZNwsjqb8Rg0Ddpt6PdTXhgmnaHgRqnjOM6uQilDhOVgOR5yuUyVRmFI1Gqz1HVkkhCOx8SWjYwknU6T2p3Kef6CQb+/G4pumFxUFG5+tylXa3zKHnNymqecL1KpKvw6K1DKFdA6PcYTh8kEskcV9vb3aa+Uv2Z5pbSlDtHGc3Rdx7PddODK5sIPcL0Iw4DRzGE+n6e/2VPLfwD7icw7vI9cZQAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;불리언 연산을 통한 이진법 덧셈&quot; title=&quot;불리언 연산을 통한 이진법 덧셈&quot; src=&quot;/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/fcda8/boolean-add.png&quot; srcSet=&quot;/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/12f09/boolean-add.png 148w,/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/e4a3f/boolean-add.png 295w,/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/fcda8/boolean-add.png 590w,/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/4b446/boolean-add.png 877w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;위의 과정은 처음 보면 복잡해보일 수 있겠지만 핵심은 간단하다.
바로 각 자릿수에 있는 1을 참으로, 0을 거짓으로 간주하고
각 자릿수의 숫자들에 대해 AND 연산과 XOR 연산을 수행하는 것이다.
이때 &lt;strong&gt;AND 연산 결과는 다음 자릿수에 올림을 적용 여부를 결정하며,&lt;/strong&gt;
&lt;strong&gt;XOR 연산 결과는 해당 자릿수의 값 존재 여부를 결정한다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;혹시 &lt;em&gt;엥? 그냥 더하면 되는 것을 왜 이렇게 작업하는거지?&lt;/em&gt;라는 생각이 드는가?
놀랍게도 뇌가 없는 고철 덩어리들은 그 &lt;em&gt;그냥 더하는 행위&lt;/em&gt;를 할 줄을 모른다.
즉, 인간의 지능으로 수행할 수 있는 작업들을 어떻게 해야
고철 덩어리들이 그럴듯하게 모방할 수 있을지에 대해 고민한 결과가 바로
2진법 체계와 논리연산에 기반을 둔 컴퓨터라고 볼 수 있다.&lt;/p&gt;&lt;p&gt;그리고 이처럼 기계만의 방식으로 각종 작업을 수행하기 위해 사용되는 도구가 바로
컴퓨터의 핵심 요소인 &lt;strong&gt;회로&lt;/strong&gt;라고 볼 수 있다.&lt;/p&gt;&lt;h2&gt;논리연산의 물리적 구현&lt;/h2&gt;&lt;p&gt;회로(circuit)라는 단어를 들으면 뭔지도 잘 모르겠지만
일단 머리가 갑자기 지끈거리는 것이 정상적인 반응일 것이다.
만일 그렇다면 지금 본인이 있는 방의 전등을 한 번 껐다 켜보자.
그대는 스위치에 물리적인 조작을 가함으로써 회로를 조작한 것이다.
물론 현대 사회의 컴퓨터는 그대가 조작한 스위치에 비해 훨씬 복잡한 구조를 지니고 있다.
해당 게시물에서는 위에서 언급한 내용을 중심으로 이에 대해 아주 가볍게만 다루고자 한다.&lt;/p&gt;&lt;p&gt;앞서 우리는 컴퓨터가 덧셈 작업을 수행하기 위해 XOR 연산과 AND 연산을
활용한다는 점에 대해 이야기하였다.
그렇다면 컴퓨터는 어떠한 물리적 장치를 사용하여 이러한 연산을 수행할 수 있을까?&lt;/p&gt;&lt;p&gt;또한 예를 들어 계산기에 &lt;code&gt;3 + 4&lt;/code&gt;라는 내용을 입력했을 때
우리가 &lt;code&gt;=&lt;/code&gt;를 눌러 실제로 연산을 실행하기 전까지
계산기는 어떻게 3과 4라는 값을 기억할 수 있을까?
그리고 계산이 끝나고 화면에 출력되는 &lt;code&gt;7&lt;/code&gt;이라는 값은 어떻게 그대로 유지될 수 있을까?&lt;/p&gt;&lt;h3&gt;논리 게이트&lt;/h3&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/5ae9e4bc74b9997000840acee978d0ac/63a68/logic-gate.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:51.35135135135135%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABV0lEQVQoz3VSXW+CQBDk//8l+1RN6kMLmgpaEoFDqEbxW0FBmGbWHAVtNyF73M3Nzc6uUVUVGN9xhP5bH6ZlIc8L2eOZPmeejB2Y1gDN0BiNM/Qi8D10u68YDIdIswzX67UG3S+WsEefeP8w5Z/neZ4/kRtclGUpG0mSYLvdYrVaYb/f43g84nK5IE3T+lIYhoKLokjy6XQSnMYYTbmWZcHzPCFlLJdLzOdzbDabmtA0TcxmM6zXa8GRlLjD4XAn1FIZ5/NZPhLwy7KsJirLO4ZKbrebEO12uwdbql8PWcpkMoYKFZqPNCsIlYJt2wiC4M/GiELtn22P0Hnp4Mt1/+0gy+32enDGzhNhqylN2QyW2vTt0RY2ik2hh1qQzq2m0GillGR6NJ1OEcdxa4SokiUTx0ngRBCjBbQUFkUhl3m4WCxECdVyX2N835cuu64rj1Ix51F7+AN7BgIfT1w+mwAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;논리 게이트&quot; title=&quot;논리 게이트&quot; src=&quot;/static/5ae9e4bc74b9997000840acee978d0ac/fcda8/logic-gate.png&quot; srcSet=&quot;/static/5ae9e4bc74b9997000840acee978d0ac/12f09/logic-gate.png 148w,/static/5ae9e4bc74b9997000840acee978d0ac/e4a3f/logic-gate.png 295w,/static/5ae9e4bc74b9997000840acee978d0ac/fcda8/logic-gate.png 590w,/static/5ae9e4bc74b9997000840acee978d0ac/63a68/logic-gate.png 629w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;논리 게이트(logic gate)란 입력 값들에 대해
일정한 불리언 연산을 수행한 결과를 출력하는 장치라고 볼 수 있다.
릴레이, 진공관, 트랜지스터, 집적회로 등 다양한 기술을 이용하여 구현될 수 있으며,
기본적으로 전압 수준에 따라 1 혹은 0을 나타내는 전자회로로 구성된다.
그리고 이러한 게이트가 기본 단위로 모여
더욱 구체적이고 복잡한 기능을 수행하는 회로를 구성하게 된다.
그러한 회로 중 하나가 바로 메모리 회로의 핵심 부품이 되는 플립플롭(flip-flop)이다.&lt;/p&gt;&lt;p&gt;플립플롭은 다양한 구조를 띠지만 핵심 원리는 자체는 간단하다.&lt;div num=&quot;1&quot;&gt;&lt;/div&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;출력값으로 0 혹은 1의 값이 유지된다.&lt;/li&gt;&lt;li&gt;특정 입력값이 &lt;strong&gt;일시적으로&lt;/strong&gt; 변화하는 경우, 출력값은 변화한다.&lt;/li&gt;&lt;li&gt;해당 입력값이 다시 기존값으로 돌아가더라도 &lt;strong&gt;변화한 출력값은 그대로 유지된다.&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;이해를 위해 매우 간략화된 플립플롭 구조를 한번 살펴보자.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/5e44e90a71d57e2ba0dad4abd8ce1870/bb3ba/flip-flop-example.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:33.78378378378378%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABL0lEQVQoz2WR646CMBCFff9nWxP/yKUCLRWLgAa5Cg3lmBkXN7s7SUNnOPNl5nSHPzEMAx+KxTn0Q495nn9ppnnGbO0nt9Z+NLuu63A6nWCMQV3XaJsGWimIIECRpoijiGtSSj63qsLteoWKIgRhiPv9DmMu/GVg3/fY77+gtcbhcOBimqYMLI2BlhKrtfwvy3Mcj0dM44iyKOD7PpRS8DyP+9Z1xW6aJvieByEEQynyPIfWKYJQoCpLOOeg4hjd+YwwDFmTZRnOlAuBoih+gHSh/auq4pW2eD6fuNJqSr19It/6gYGbX6Qh8DYIA8nDJEl4zQ1IU8VxzBOQt8uyvPNLhiiK+BHIMymT/0ASPx41mqbhRp54mviBxnHE6hyv3LYta+z365JVBKX61kfAF+7FEsGyAlZhAAAAAElFTkSuQmCC&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;플립플롭&quot; title=&quot;플립플롭&quot; src=&quot;/static/5e44e90a71d57e2ba0dad4abd8ce1870/fcda8/flip-flop-example.png&quot; srcSet=&quot;/static/5e44e90a71d57e2ba0dad4abd8ce1870/12f09/flip-flop-example.png 148w,/static/5e44e90a71d57e2ba0dad4abd8ce1870/e4a3f/flip-flop-example.png 295w,/static/5e44e90a71d57e2ba0dad4abd8ce1870/fcda8/flip-flop-example.png 590w,/static/5e44e90a71d57e2ba0dad4abd8ce1870/efc66/flip-flop-example.png 885w,/static/5e44e90a71d57e2ba0dad4abd8ce1870/bb3ba/flip-flop-example.png 1121w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;해당 플립플롭에서 두 입력값이 모두 0일 때 출력값은 0으로 유지된다.
이때 아래쪽의 입력값이 0으로 고정된 상태로
위쪽의 입력값이 1로 변하면 출력값은 1로 변하게 된다.
이때 변한 출력값은 입력값이 다시 0으로 되돌아가더라도 그대로 유지된다는 특성을 띤다.
즉, 입력값 중 하나가 순간적으로 &lt;code&gt;0-&amp;gt;1-&amp;gt;0&lt;/code&gt;로 깜빡임으로써 &lt;em&gt;디폴트 출력값&lt;/em&gt;이 &lt;code&gt;0-&amp;gt;1&lt;/code&gt;로 변했다는 것이다.
한편 반대로 위의 입력값이 0으로 고정된 상태에서
아래쪽의 입력값이 &lt;code&gt;0-&amp;gt;1-&amp;gt;0&lt;/code&gt;으로 깜빡이는 경우 &lt;em&gt;디폴트 출력값&lt;/em&gt;은 다시 &lt;code&gt;1-&amp;gt;0&lt;/code&gt;로 변하게 된다.&lt;/p&gt;&lt;p&gt;바로 이러한 성질을 활용함으로써 우리는 비트 단위의 데이터를
회로 구조상 특정 물리적인 위치에 &lt;em&gt;얼려놓을&lt;/em&gt; 수 있게 된다.
그리고 이처럼 저장해놓은 데이터를 우리는 보다 복잡한 연산의 입력값으로 사용하고,
해당 연산의 출력값을 다시 다른 위치에 저장해놓을 수 있다.
이는 마치 인간의 뇌의 작업기억(working memory)에서 각종 정보를 실시간으로 관리하고
별도의 작업에 활용하는 것과 마찬가지이다.&lt;/p&gt;&lt;h3&gt;가산기&lt;/h3&gt;&lt;p&gt;그렇다면 플립플롭 회로와 같은 방식으로 저장된 데이터를 활용하여
실제로 어떻게 덧셈 연산을 수행할 수 있을까?
아래는 반가산기(half adder)와 전가산기(full adder)의 기본 구조다.
이때 출력값의 Carry는 올림 여부를, Sum은 특정 자릿수에 실제로 저장하는 값을 의미한다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/21c0cedd0264d1e5073835cf35a8b19e/33e10/adders.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:35.810810810810814%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA9UlEQVQoz4VRy26EMBDj//9re15uIBAIOBDCM7zfrjxqqu4etpZGIYnHYwcHH3Df90sR13Vh33dM04TzPGVv7wiHGxKO48CyLOi6DsMwvJDYpJRCmqZwXRdxHMP3fTRNgzAMUSglPeSJoDEGfd/j6/EQQtu2KIpCGqwwzyjkPl1EUYQgCJDnufTSCN2S6/yNmGUZkiRBVVWytySLcRxlYF3XMrAsS8zzLAl/I9MmD+nA8zwpxitLLQIW27YhS1MZxiKHDhld6wK9MSIskWmZgnay+bnku1rwm4601rIyCbnrusoddeQN8Q9sZK5Mwrfmj2NR7B3fZssbqHDSYj4AAAAASUVORK5CYII=&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;반가산기와 전가산기&quot; title=&quot;반가산기와 전가산기&quot; src=&quot;/static/21c0cedd0264d1e5073835cf35a8b19e/fcda8/adders.png&quot; srcSet=&quot;/static/21c0cedd0264d1e5073835cf35a8b19e/12f09/adders.png 148w,/static/21c0cedd0264d1e5073835cf35a8b19e/e4a3f/adders.png 295w,/static/21c0cedd0264d1e5073835cf35a8b19e/fcda8/adders.png 590w,/static/21c0cedd0264d1e5073835cf35a8b19e/33e10/adders.png 844w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;좌측의 반가산기의 구조는 이해하기 쉬울 것이다.
각 자릿수의 입력값 두 개를 받아
AND 연산 결과로 올림 여부를 결정하고,
XOR 연산 결과를 해당 자릿수의 값으로 저장한다는
위에서 설명한 불리언 연산을 통해 덧셈 작업의 핵심 원리에 정확히 대응된다.
그런데 반가산기는 오직 2&lt;sup&gt;0&lt;/sup&gt; 자리에서의 연산에만 사용이 가능하다.
2&lt;sup&gt;1&lt;/sup&gt; 자리부터는 바로 아래 자릿수에서 올림 여부가 결정되었는지를 고려해야 하기 때문이다.
즉, 2&lt;sup&gt;1&lt;/sup&gt; 자리부터는 각 자릿수의 입력값 두 개만이 아니라 올림 여부까지 포함하여
총 3가지의 입력값을 받아 처리해야 하며, 우측의 전가산기를 통해 이러한 연산을 처리할 수 있게 된다.&lt;/p&gt;&lt;p&gt;실제 컴퓨터에 들어가는 칩(chip) 하나 하나는
초고밀도 집적회로(VLSI) 기술을 통해 이처럼 다양하고 세부적인 구성을 띤 수백만 개의 회로로 구성된다.&lt;/p&gt;&lt;h2&gt;맺으며&lt;/h2&gt;&lt;p&gt;해당 게시글은 최대한 다양한 주제를 겉핥기식으로 다루고 있다.
그러나 전달하고자 하는 핵심은 간단하다.
컴퓨터와 프로그래밍 언어는 전부 인간이 특정한 의도를 지니고 만들어낸 것이며,
컴퓨터는 복잡하지만 체계적으로 설계된 &lt;strong&gt;물리적인 도구&lt;/strong&gt;라는 것이다.&lt;/p&gt;&lt;p&gt;그리고 논리연산의 결과와 비트에 담기는 데이터가 참/거짓 혹은
1/0와 같이 두 가지 값으로 구분된다는 점은
우연의 일치가 아니라 바로 컴퓨터의 구조에 대해
옅볼 수 있는 중요한 힌트라고 볼 수 있다.&lt;/p&gt;&lt;p&gt;보다 체계적이고 깊이 있는 지식을 원한다면 컴퓨터 구조에 관한
서적을 찾아보는 것을 권장한다.&lt;/p&gt;&lt;hr/&gt;&lt;div&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788993712629&quot;&gt;컴퓨터 과학 총론&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9791189909284&quot;&gt;한 권으로 읽는 컴퓨터 구조와 프로그래밍&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;div num=&quot;1&quot;&gt;&lt;p&gt;엄밀히 말해서 이는 플립플롭보다는 래치(latch)의 특성이다.
플립플롭은 특정한 조건을 충족한 래치라고 볼 수 있다.
실제 메모리 회로에서 사용되는 플립플롭의 구조와 그 의미에 대해 알아보고 싶다면
&lt;strong&gt;&lt;div to=&quot;/computer-science/latch-and-flip-flop&quot;&gt;이 게시글&lt;/div&gt;&lt;/strong&gt;을
참고하기를 바란다.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[개발 블로그를 시작하며]]></title><description><![CDATA[블로그 버전 1의 개발을 완료하였다. 10일 정도 작업을 하였고 현재 도메인을 구글과 네이버에 각각 등록한 상황이다. 수정 및 추가하고 싶은 기능들이 아직도 꾸준히 생겨나고 있으나 이대로는 끝이 없을 듯 하여 일단 나의 첫 글을 남기고자 한다.]]></description><link>https://bugoverdose.github.io/essay/starting-a-dev-blog/</link><guid isPermaLink="false">https://bugoverdose.github.io/essay/starting-a-dev-blog/</guid><pubDate>Wed, 05 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;지난 해 12월 23일에 깃헙에 저장소를 생성한 이후 올해 1월 4일을 기준으로
블로그 v1.0.0을 완료하였다.
실질적으로 약 10일 정도 작업을 하였고,
&lt;code&gt;github.io&lt;/code&gt; 도메인으로 현재 구글과 네이버에 각각 등록한 상황이다.&lt;/p&gt;&lt;p&gt;수정 및 추가하고 싶은 기능들이 아직도 꾸준히 생겨나고 있으나
이대로는 끝이 없을 듯 하여 일단 나의 첫 글을 남기고자 한다.&lt;/p&gt;&lt;h2&gt;나는 왜 블로그를 시작하였는가&lt;/h2&gt;&lt;p&gt;나는 온라인에 글을 올리는 취미가 딱히 없는 사람이다.
트위터 등 SNS에 글을 올리는 사람들의 심리도 이해는 되지만 딱히 공감하지는 않는다.&lt;/p&gt;&lt;p&gt;다만, 나는 공부한 내용을 체계적으로 정리하는 작업을 대학생활 동안 꾸준히 해왔다.
동일한 내용도 나만의 언어로 다시 한번 정리함으로써
기존에 알던 정보들과 새로운 지식들이 통합되고
특정 주제에 대해 보다 깊이 있는 이해가 가능해지기 때문이다.&lt;/p&gt;&lt;p&gt;2020년부터는 프로그래밍과 관련하여 공부한 것들을 텍스트 파일 및 마크다운 파일로 정리하고
&lt;code&gt;~-study-note&lt;/code&gt;라는 명칭의 깃헙 저장소들에서 관리하기 시작하였다.
그러나 시간이 지난 후, 몇 달 전에 내가 열심히 정리한 글들을 다시 보았을 때
도저히 내용을 이해할 수가 없다는 문제가 확인되었다.
이 때문에 현재는 대부분의 저장소들을 private으로 바꾼 상태이다.
이 상황에 대해 고민해본 결과, 해당 글들이 타인이 읽는 것을 염두에 두지 않고
작성되었기 때문에 가독성이 낮은 것이라는 결론에 도달하였다.
해당 저장소들에 별을 주신 분들도
내가 작성해놓은 내용들을 실제로 읽고 있지는 않을 것이라고 생각한다.&lt;/p&gt;&lt;p&gt;때문에 나는 앞으로 내가 공부한 내용들을 독자를 염두에 두고 정리하고자 하며,
이를 위해 실제로 독자가 존재하는 환경에 글을 올리고자 한다.&lt;/p&gt;&lt;h2&gt;나는 왜 블로그를 직접 개발하였는가&lt;/h2&gt;&lt;p&gt;사실 단순히 글을 올릴 수 있는 환경은 참 많다. SNS나 네이버 블로그 외에도
개발 블로그에 특화된 플랫폼들도 꽤 존재하는 것으로 안다.
특히 &lt;a href=&quot;https://velog.io/&quot;&gt;벨로그&lt;/a&gt;를 사용하면 이미 훌륭하게 개발된 템플릿을 토대로
글을 쓰는 작업에 온전히 몰두할 수 있으며
보다 많은 사람들에게 내가 작성한 글이 전달될 것이라고 생각한다.&lt;/p&gt;&lt;p&gt;그러나 나의 주변 사람들 중에는 &lt;code&gt;gatsby-starter-bee&lt;/code&gt;&lt;div num=&quot;1&quot;&gt;&lt;/div&gt;
혹은 &lt;code&gt;gatsby-starter-blog&lt;/code&gt;&lt;div num=&quot;2&quot;&gt;&lt;/div&gt;
와 같은 템플릿을 활용하여 개발 블로그를 만든 사람들이 상당히 많다.
그들이 있었기 때문에 나도 당연히 Gatsby로 직접 개발 및 배포해야 한다고 생각했었고
종강하자마자 바로 공식 사이트의 튜토리얼을 읽기 시작하였다.&lt;/p&gt;&lt;h2&gt;나는 왜 템플릿을 사용하지 않았는가&lt;/h2&gt;&lt;p&gt;다만 나의 경우 템플릿을 사용하지 않고 &lt;code&gt;gatsby new&lt;/code&gt;를 실행하여 만들어지는
디폴트 프로젝트를 기반으로 필요에 따라 플러그인들을 하나하나
설치 및 설정해나가면서 개발을 진행하였다.
디자인의 경우에도 &lt;code&gt;gatsby-plugin-styled-components&lt;/code&gt;를 설치한 이후,
프로젝트 전체에 reset css를 먹이고 컴포넌트별로
css 속성들을 전부 하나 하나 작성하면서 디자인해나갔다.&lt;/p&gt;&lt;p&gt;수많은 템플릿이 존재한다는 점이 개츠비의 장점 중 하나인데
내가 왜 굳이 이처럼 제로베이스에서 시작하였는지에 대해 한번 설명하고자 한다.&lt;/p&gt;&lt;h3&gt;가오&lt;/h3&gt;&lt;p&gt;첫째는 당연히 가오 때문이다. 이것은 무척 중요하다.
현재 나는 굳이 따지자면 백엔드로 분류되지만
일단은 웹 프론트엔드로 소프트웨어 개발에 입문한 사람이다.
내가 하나부터 열까지 전부 직접 구현할 수 있는데 굳이 다른 사람의 코드에 의존하고 싶지 않았다.&lt;/p&gt;&lt;h3&gt;공부&lt;/h3&gt;&lt;p&gt;둘째는 공부 목적이다.
개발과정에서 SEO(검색엔진 최적화), Open Graph 프로토콜 등 다양한 주제를 공부하고
그 지식을 실제 프로젝트에 적용해볼 기회가 생겨서 무엇보다도 좋았다.
해당 사이트가 활성화되면 Google Analysis 등 다른 도구들도 본격적으로 활용해보고자 한다.&lt;/p&gt;&lt;p&gt;또한 Gatsby에 이번 기회에 입문하였는데 BFF(Backend For Frontend) 프레임워크답게
mdx, yaml, json 파일의 형식으로 자료를 효율적으로 구조화하고
GraphQL 쿼리로 이를 조회하는 경험을 할 수 있어서 굉장히 좋았다.
관계형 데이터베이스와 SQL문이라는 고정된 형식에서 벗어남으로써
백엔드 개발자로서의 전체적인 시야가 더 넓어질 수 있었다고 생각한다.&lt;/p&gt;&lt;h3&gt;통제&lt;/h3&gt;&lt;p&gt;무엇보다도 프로젝트에 대한 통제력을 확보하는 것이 가장 중요한 이유였다.&lt;/p&gt;&lt;p&gt;프로젝트 내에 존재하는 모든 코드에 대해 개발자 본인이 이해를 하고 있어야
각종 기능, 디자인적인 요소, 라우팅 등을 자유자제로 수정 및 추가할 수 있지 않은가.&lt;/p&gt;&lt;p&gt;만일 &lt;code&gt;gatsby-starter-blog&lt;/code&gt;와 같은 탬플릿의 전반적인 디자인과 기능들이
내 마음에 들었다면 해당 탬플릿을 그냥 사용하고 일부 코드만 적절하게 수정하는 것이
가장 효율적이었을지도 모른다.
그러나 해당 템플릿의 디자인과 라우팅은 내 취향에 전혀 맞지 않았다.&lt;/p&gt;&lt;p&gt;탬플릿을 기반으로 코드를 전부 뜯어고칠 바에야
차라리 모든 디자인과 기능을 제로베이스에서 직접 구현하는 것은 당연한 선택지였다고 볼 수 있다.
현재 결과물은 만족스럽고 꾸준한 리팩토링으로 인해 유지보수도 용이하게 관리되고 있다.&lt;/p&gt;&lt;h3&gt;버전 이슈&lt;/h3&gt;&lt;p&gt;나는 현재 릴리즈된 버전들 중 가장 최신인 Gatsby v4.4를 사용하여 프로젝트를 셋업하였다.
물론 버전이라는 것이 높으면 높을수록 무조건 좋은 것만은 아니다.
실제로 &lt;code&gt;gatsby-starter-bee&lt;/code&gt;의 경우
Gatsby v2를 사용하는 올-드한 프로젝트임에도 많은 이들의 사랑을 꾸준히 받고 있다.&lt;/p&gt;&lt;p&gt;그렇지만 Gatsby는 현재 빠른 속도로 발전하는 프레임워크이기 때문에
일단은 최신 버전을 사용하는 것이 유지보수 측면에서 장기적으로 적절하다고 생각한다.
2021년 3월과 10월에 각각 v3.0.0과 v4.0.0이 릴리즈된 것만 보아도
버전 업데이트 속도가 실로 정신나갔다고밖에 말할 수 없다.&lt;/p&gt;&lt;p&gt;Gatsby의 프로젝트 구조 및 플러그인 설정 방법에 대한 이해가 부족한
사람이 별 생각 없이 탬플릿을 사용할 경우,
향후 플러그인 중 하나가 deprecate되거나 버전 마이그레이션이 필요한 상황이 생겼을 때
과연 문제 상황에 원활하게 대처할 수 있을지 솔직히 의구심이 든다.&lt;/p&gt;&lt;h2&gt;나는 어떤 글을 쓸 것인가&lt;/h2&gt;&lt;p&gt;솔직히 잘 모르겠다. 거 뭐 해본적이 있어야지 말이다.
스스로를 &amp;#x27;필자&amp;#x27;라고 지칭해야 할지 &amp;#x27;나&amp;#x27;라고 지칭하는 것이 적절한지도 현재 고민하는 중이다.
전반적으로 문어체를 추구할지 구어체에 가깝게 작성할지도 생각 중이다.&lt;/p&gt;&lt;p&gt;그렇지만 일단 현재 블로그 결과물이 생각보다 잘 나왔고,
이왕 이렇게 된거 한 번 제대로 관리해보고자 한다.
현재 구현해놓은 페이지네이션, 태그 사전 등의 기능이 제대로 동작하려면
적어도 11개 이상의 글은 존재해야 하기 때문에 일단은 뭐라도 쓰기는 할 생각이다.&lt;/p&gt;&lt;h3&gt;글쓰기 윤리에 대하여&lt;/h3&gt;&lt;p&gt;기본적으로 모든 게시글은 개발, 실험 등 개인적인 경험과 독서 내용에 기반을 두고 작성하고자 한다.
다만, 참고자료가 조금이라도 존재할 경우 본문에 최소한의 언급을 하고,
각 게시글 하단에 관련 링크를 추가하고자 한다.&lt;/p&gt;&lt;hr/&gt;&lt;div&gt;&lt;div num=&quot;1&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/JaeYeopHan/gatsby-starter-bee&quot;&gt;gatsby-starter-bee&lt;/a&gt;: 오픈소스 블로그 탬플릿&lt;/p&gt;&lt;/div&gt;&lt;div num=&quot;2&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://www.gatsbyjs.com/starters/gatsbyjs/gatsby-starter-blog/&quot;&gt;gatsby-starter-blog&lt;/a&gt;: Gatsby Starter Library에 등록된 개츠비 공식 블로그 탬플릿&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded></item></channel></rss>