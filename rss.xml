<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed | bugoverdose]]></title><description><![CDATA[공부하고 경험한 내용을 깔끔하게 설명하는 것을 목표로 하는 개발 블로그입니다. 컴퓨터 구조, 네트워크, 웹 개발, 백엔드 개발 등 다양한 주제를 포괄적으로 다룹니다.]]></description><link>https://bugoverdose.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sat, 08 Jan 2022 10:23:44 GMT</lastBuildDate><item><title><![CDATA[컴퓨터는 어떻게 사고하는가: 비트와 논리연산에 대하여]]></title><description><![CDATA[논리연산이라는 개념에서 출발하여 하이레벨에서 로우레벨로 차근차근 내려가봅니다. 기계어, 비트, 불리언 연산, 게이트, 플립플롭 등의 개념에 대해 가볍게 다룹니다. 궁극적으로 컴퓨터의 구조 및 동작 방식에 대한 최소한의 이해를 목표로 합니다.]]></description><link>https://bugoverdose.github.io/computer-science/bit-and-logic-operation/</link><guid isPermaLink="false">https://bugoverdose.github.io/computer-science/bit-and-logic-operation/</guid><pubDate>Thu, 06 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;논리연산(logic operation)이란 기본적으로 불리언 값,
즉 참 혹은 거짓 중 하나의 값을 반환하는 연산을 의미한다.
예를 들어 자바스크립트 및 JSX 문법을 기준으로
&lt;code&gt;if (a &amp;gt; 5) return true&lt;/code&gt;의 &lt;code&gt;a &amp;gt; 5&lt;/code&gt; 부분,
&lt;code&gt;a === 1 ? &amp;quot;1이다&amp;quot; : &amp;quot;1이 아니다&amp;quot;&lt;/code&gt;의 &lt;code&gt;a === 1&lt;/code&gt; 부분,
&lt;code&gt;{!loading &amp;amp;&amp;amp; &amp;lt;Component /&amp;gt;}&lt;/code&gt;의 &lt;code&gt;!loading&lt;/code&gt; 부분과 같이
조건문에 해당되는 코드들에서는 전부 논리연산이 발생한다고 볼 수 있다.&lt;/p&gt;&lt;p&gt;그러나 논리연산은 이처럼 프로그래밍 언어에서 조건문을
수행하도록 명시적으로 지정하는 경우에만 일어난다고 볼 수 없다.
하드웨어 레벨에서 보았을 때 컴퓨터에서 일어나는 모든 처리는
본질적으로 논리연산에 기반을 두고 동작하는 것으로 보인다.&lt;/p&gt;&lt;h2&gt;컴퓨터의 개념과 기계어&lt;/h2&gt;&lt;p&gt;사실 컴퓨터라는 용어는 기계로서의 컴퓨터가 발명되기 이전부터 존재했다.
당시 컴퓨터는 계산 도구를 활용하여 숫자와 관련된 단순 계산 작업을 하는 사람들, 즉 직종을 의미하였다.
물론 현대에 와서 기계로서의 컴퓨터는 극한으로 고도화되었고,
인간 컴퓨터라는 직무를 대체하게 되었다. 그러나 과거와 마찬가지로
&lt;em&gt;상황에 따라 들어온 입력에 대해 적절한 계산을 수행하고 그 값을 출력한다&lt;/em&gt;는 점에서
그 본질은 크게 변하지 않았다고 볼 수 있다.&lt;/p&gt;&lt;p&gt;그렇다면 인간과 기계로서의 컴퓨터의 차이는 어디에 있을까?
다양한 측면이 있겠지만 필자는 가장 큰 차이가 바로 &lt;strong&gt;언어 체계&lt;/strong&gt;에 있다고 생각한다.
인간의 언어는 &lt;em&gt;텍스트&lt;/em&gt;에 기반하는데 반해
컴퓨터의 언어인 기계어는 &lt;em&gt;비트와 논리연산&lt;/em&gt;에 기반을 두고 있다.&lt;/p&gt;&lt;h3&gt;인간의 언어: 텍스트&lt;/h3&gt;&lt;p&gt;.js, .py, .java 등 어떤 확장자를 사용하든지 간에
대부분의 경우 프로그래머가 파일에 작성하는 코드는 결국 본질적으로 텍스트에 불과하다.
각 프로그래밍 언어의 문법을 기준으로
각 텍스트는 변수의 선언, 값 할당, 제어문 등 다양한 의미를 지닐 수 있지만
이는 인간의 기준에서만 그러하다.
컴퓨터의 입장에서 이 모든 코드는 그저 텍스트일 뿐이며,
이러한 텍스트가 컴파일러에 의해 기계어로 변환되어야 비로소 컴퓨터는 이를 이해하고 실행할 수 있게 된다.&lt;/p&gt;&lt;p&gt;별도의 IDE 없이 메모장으로 만든 텍스트 파일에 자바 문법 코드를 작성하고
.java 확장자로 저장하면 컴파일러로 해당 파일의 코드를 실행할 수 있다는 점이
이러한 과정을 명시적으로 보여준다.
마찬가지로 url의 쿼리나 해쉬 값 혹은 input 태그의 값으로 특정한 형식의 텍스트를 입력하여
서버에 요청을 보냄으로써
애플리케이션에 코드를 주입하는 종류의 웹공격이 가능한 것도 바로 이 점 때문이다.&lt;/p&gt;&lt;h3&gt;기계어: 비트와 연산&lt;/h3&gt;&lt;p&gt;그렇다면 컴파일러에 의해 변환된 코드를 컴퓨터는 어떻게 이해할까?
결론부터 말하자면 &lt;strong&gt;컴퓨터의 세계는 수학의 세계&lt;/strong&gt;라고 볼 수 있다.
다만, 인간은 일반적으로 10진법을 사용하는 데 반해 컴퓨터는 2진법을 사용하여 계산을 한다.
이는 컴퓨터가 모든 데이터를 비트로써 &lt;em&gt;물리적으로&lt;/em&gt; 저장하고 다룬다는 점을 뜻한다.&lt;/p&gt;&lt;p&gt;비트(bit)란 binary digit의 줄임말로 0 혹은 1 중 하나의 값을 지니는 단위라고 이해하면 편하다.
그리고 복수의 비트를 하나의 단위로 간주할 경우
각 비트가 지니는 0 혹은 1의 &lt;em&gt;값&lt;/em&gt;과 각 비트의 &lt;em&gt;위치&lt;/em&gt;를 기준으로
각 단위는 2진법 체계의 값을 나타낼 수 있게 된다.
대표적인 예로 8비트로 구성된 하나의 바이트(byte)는 0부터 2&lt;sup&gt;8&lt;/sup&gt;-1까지의 값들을
나타낼 수 있다.&lt;/p&gt;&lt;p&gt;그렇다면 여기서 우리는 의문을 가져보아야 한다.
대체 왜 컴퓨터는 모든 것을 10진법이 아닌
2진법으로 나타내고 비트로 데이터를 다루는 것일까?
바로 이 지점에서 우리는 드디어 &lt;strong&gt;로우 레벨에서의 논리연산&lt;/strong&gt;과
&lt;strong&gt;전자회로&lt;/strong&gt;에 대한 이야기를 시작해볼 수 있다.&lt;/p&gt;&lt;h2&gt;논리연산의 본질&lt;/h2&gt;&lt;p&gt;논리연산이란 &lt;em&gt;입력된 비트들의 값&lt;/em&gt;을 토대로
&lt;em&gt;새로운 비트&lt;/em&gt;를 &lt;strong&gt;만들어내는 동작&lt;/strong&gt;이라고 볼 수 있다.
위에서 우리는 논리연산을 참 혹은 거짓 중 하나의 값을 반환하는 연산이라고 정의하였다.
그리고 비트에 담기는 1 혹은 0의 값이 바로 이 참과 거짓에 해당된다고 볼 수 있다.&lt;/p&gt;&lt;p&gt;이해를 위해 &lt;code&gt;if (a &amp;gt; 5) return true&lt;/code&gt;라는 코드를 보면
&lt;code&gt;a &amp;gt; 5&lt;/code&gt;는 a의 값이 5보다 큰 지 확인하고
그 값이 참이면 참을, 거짓이면 거짓을 반환하라는 의미이다.
즉 해당 연산의 결과로 인해
&lt;strong&gt;참 혹은 거짓이라는 값이 컴퓨터 내에 물리적으로 생성&lt;/strong&gt;되고
해당 값을 조건절로 감싸고 있는 if 문은 해당 값에 따라 조건문 내부의 코드를
실행할지 말지에 대해 결정하게 되는 것이다.
그리고 해당 코드가 실행되는 과정에서
변수 a에 담긴 값과 5라는 리터럴은 해당 위치에서 호출되었지만
컴퓨터의 메모리에서 사라지지 않으며 이후 다른 코드들에서 그대로 쓸 수 있다.&lt;/p&gt;&lt;h2&gt;불리언 연산&lt;/h2&gt;&lt;p&gt;그동안 참 혹은 거짓의 값이라고 말한 데이터는
각종 프로그래밍 언어들에서 boolean이라는 자료형으로 불린다.
해당 명칭은 영국의 수학자 George Boole에 이름에서 나온 것이며
그는 불리언 대수(Boolean algebra)라는 4가지 연산 규칙을 고안한 사람이다.&lt;/p&gt;&lt;p&gt;그는 NOT, AND, OR, XOR라는 불리언 연산자를 제안하였는데
바로 이 연산자들이 논리연산, 회로의 뼈대라고 볼 수 있다.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;NOT : 논리적 반대를 의미한다. 유일하게 단일 비트에 대해 적용된다.&lt;ul&gt;&lt;li&gt;이해: 비트의 값이 거짓인 경우 참을, 참인 경우 거짓을 출력&lt;/li&gt;&lt;li&gt;본질: 입력의 상태를 반대로 반전시킨 결과를 출력&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;AND : 둘 이상의 비트에 대해 적용되지만 프로그래밍 문법에서는 두 개의 입력값만을 받는다.&lt;ul&gt;&lt;li&gt;이해: 2비트 연산의 경우 a AND b에서 a와 b가 모두 참일 때만 참을, 그 외에는 거짓을 출력&lt;/li&gt;&lt;li&gt;본질: 입력된 모든 비트가 참일 때만 참을 출력&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;OR : 둘 이상의 비트에 대해 적용되지만 프로그래밍 문법에서는 두 개의 입력값만을 받는다.&lt;ul&gt;&lt;li&gt;이해: 2비트 연산의 경우 a OR b에서 a와 b가 모두 거짓일 때만 거짓을, 그 외에는 참을 출력&lt;/li&gt;&lt;li&gt;본질: 입력된 모든 비트 중 하나만이라도 참이면 참을 출력&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;XOR : 배타적 OR(exclusive OR)의 줄임말이다. NOT, AND, OR 연산의 조합으로 구현될 수 있다.&lt;ul&gt;&lt;li&gt;첫번째 비트와 두번째 비트가 서로 다른 경우에 참. 같은 경우 거짓을 출력&lt;/li&gt;&lt;li&gt;구현 예시: (a XOR b) == (a OR b) AND (NOT(a AND b))&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;사실 XOR 외에는 전부 일반적인 프로그래밍 언어들에 기초 문법으로
존재하는 기능들이기 때문에 개념을 이해하는 데 어려움은 없을 것이다.
그런데 앞서 언급했듯이 컴퓨터는 이처럼 프로그래밍 문법으로 명시적으로
작성하지 않은 코드에 대해서도 논리연산을 적용하여 실행한다.
그리고 위의 불리언 연산자들은 바로 이러한 연산을 이해하기 위한 핵심이라고 볼 수 있다.&lt;/p&gt;&lt;h3&gt;예제: 컴퓨터의 사칙연산&lt;/h3&gt;&lt;p&gt;누구나 쉽게 이해할 수 있도록 사칙연산 중에서도 덧셈을 예제로 준비해보았다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/b9e4c95e61067a2b1f51bb8a3875789d/d93d9/decimal-add.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:22.2972972972973%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA10lEQVQY012P22qDQBRF/f+f6ZO0tGkriUovJioZDY29QB7siLQGxwvFqas4LRK64TzsxWafcyz+5Ps+WZZxqpXrceMGjOM4M/tqySYWsz82X1xcu8RRaLzVdR1KKYQQpGlq4MTatiWKYm69NVNd3/e0TYPjr4m2O5PTeuCQl6zuQ7L9k1lsSSnJ85wkScxM5UVRMPFNGHJmL6hrRVmWSPnO+cJl6d3RKMWx+mS7e8a+dAgeH6iqCot/On1vGDR+IND6e2bJ/mAuHMdfVnzUOF7A2+uLyf0Amc0pBQ+aEJcAAAAASUVORK5CYII=&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;십진법 덧셈&quot; title=&quot;십진법 덧셈&quot; src=&quot;/static/b9e4c95e61067a2b1f51bb8a3875789d/fcda8/decimal-add.png&quot; srcSet=&quot;/static/b9e4c95e61067a2b1f51bb8a3875789d/12f09/decimal-add.png 148w,/static/b9e4c95e61067a2b1f51bb8a3875789d/e4a3f/decimal-add.png 295w,/static/b9e4c95e61067a2b1f51bb8a3875789d/fcda8/decimal-add.png 590w,/static/b9e4c95e61067a2b1f51bb8a3875789d/efc66/decimal-add.png 885w,/static/b9e4c95e61067a2b1f51bb8a3875789d/c83ae/decimal-add.png 1180w,/static/b9e4c95e61067a2b1f51bb8a3875789d/d93d9/decimal-add.png 1243w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;먼저 우리가 초등학교에서 배운 10진법에서의 덧셈 방식을 한번 봐보자.
우리는 두 수가 있을 때 각 자릿수의 값을 더한 개별 결과에 대해
해당 값이 10 이상인 경우 한 자리 위에 1의 값을 더하는 올림 작업을 수행하고,
해당 자릿수의 1의 자리 값은 그대로 해당 자릿수에 할당한다.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;1의 자리는 &lt;code&gt;5 + 0 = 5&lt;/code&gt;이므로 올림 작업을 수행하지 않고 5를 그대로 할당한다.&lt;/li&gt;&lt;li&gt;10의 자리는 &lt;code&gt;8 + 3 = 11&lt;/code&gt;이므로 올림 작업을 수행하여 일단은 1만을 할당한다.&lt;/li&gt;&lt;li&gt;100의 자리는 &lt;code&gt;1 + 1 = 2&lt;/code&gt;이지만 올림을 적용받으므로 &lt;code&gt;2 + 1 = 3&lt;/code&gt;이 된다.&lt;/li&gt;&lt;li&gt;결국 100의 자리에서는 올림 작업을 수행하지 않으므로 3을 할당하고 &lt;code&gt;315&lt;/code&gt;가 답이 된다.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;즉, 각 자릿수에 대해 개별적으로 덧셈을 적용하고
&lt;em&gt;올림 작업 수행 여부&lt;/em&gt;와 &lt;em&gt;해당 자릿수에 할당할 값을 결정&lt;/em&gt;하는 두 가지 연산이
실행된다는 점이다.
이때 올림 작업의 경우 2진법이든 10진법이든
언제나 한 자리 위에 1을 더하는 방식으로 적용되며
10진법이기 때문에 10을 기준으로 적용 여부를 결정하게 된다.&lt;/p&gt;&lt;p&gt;이러한 원리는 10진법이든, 2진법이든, 16진법이든 동일하게 적용된다. 아래 예시를 한번 봐보자.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/803f2e975a072aedbc03fc5e6c5c9bd3/27e9a/binary-add.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:22.2972972972973%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA0klEQVQY012QX0vDMBxF+/0/kU+CDzpxTsM61FC6dja2tX8TREnT2SOJTsH7di+Hk/CL+IkxhqqqcM6dJoZh5EZIrJ1+t0y17J5SWD5Df7cz+6IlzzKWZSGy1gaJF9Z1HSDf/a614TZOcG4Om5smMtUg0+fAHY8zr50mL3uUKr6FTdNQliVFUZAkSRD3vQcU+eHA2fkVbdsxDAPli2KzlazWAqNHtB55kCl3uwQhBF3XEfEv/pVT/M8uVvfY6e8Mcq+4vN54MnT99sFaPBLH29C/AJRvLr+dshN4AAAAAElFTkSuQmCC&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;이진법 덧셈&quot; title=&quot;이진법 덧셈&quot; src=&quot;/static/803f2e975a072aedbc03fc5e6c5c9bd3/fcda8/binary-add.png&quot; srcSet=&quot;/static/803f2e975a072aedbc03fc5e6c5c9bd3/12f09/binary-add.png 148w,/static/803f2e975a072aedbc03fc5e6c5c9bd3/e4a3f/binary-add.png 295w,/static/803f2e975a072aedbc03fc5e6c5c9bd3/fcda8/binary-add.png 590w,/static/803f2e975a072aedbc03fc5e6c5c9bd3/efc66/binary-add.png 885w,/static/803f2e975a072aedbc03fc5e6c5c9bd3/c83ae/binary-add.png 1180w,/static/803f2e975a072aedbc03fc5e6c5c9bd3/27e9a/binary-add.png 1253w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;위의 &lt;code&gt;11 + 11 = 110&lt;/code&gt;은 10진법을 기준으로 &lt;code&gt;3 + 3 = 6&lt;/code&gt;으로 표현되는 매우 간단한 연산이다.
10진법과의 차이점은 각 자릿수에 할당될 수 있는 값의 범위가 0과 1로 줄어들었다는 점밖에 없다.
그런데 이처럼 값의 범위가 두 가지로 줄어들었다는 점은 너무나도 큰 의미를 지닌다.
바로 &lt;strong&gt;불리언 연산을 통해 덧셈 작업을 수행&lt;/strong&gt;할 수 있는 조건이 마련되었다는 것이다.
위에서 수행한 덧셈 작업을 불리언 연산을 통해 수행하면 다음과 같다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/4b446/boolean-add.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:81.75675675675677%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACPklEQVQ4y5WTW1PaUBSF+f9/oy996EuttqVTW62iIMpFNBSRS4BwT07ugZPL1yGClUGtXTOZ7LMmZ++1zsrJ8EYkSfL43tTTuYHt+lt85qXNTxvEcfyXW/MrHB6f0Wj10zqOH/jMW1Q9RbxSZggi4KxYoaWO/k+h6wW01QEzwyT0PMLpkE7pArtZ58tBlvNihTgKH/e92DBeN+xqU959yFIoK0zGBrM7gXHZwc63+fmtRKmmrC3HL1heq0vWdRQn+DJCAtJfYis9bGOJGYA6tHC8Z0LZLHaeh9Ewn8NoBIoCMkgbhGHI58MThDC2Gz538I9YLEBVwXVBCNAGKR0EAb6MOc5X8Tx3K8DMw7QIXViYtpt+vJRLgsBHNu8JXIeVpmAwIDJNFoFP6/Yardfn49cjVLWbqt0KxXY8rq4b1O9Vard1Dr7nyJ0XqRQuqV3XyRWuKJ3mGY+m6E0V+1ue7mWf93s/qCu3r1v2/AW94RTdtBFCELgBQljYfoA0TbyGitBjVE3SaA3wPW/X8uY2bKJ/FlJCtwtxlC4HM5NypYplWf8OZZNwsjqb8Rg0Ddpt6PdTXhgmnaHgRqnjOM6uQilDhOVgOR5yuUyVRmFI1Gqz1HVkkhCOx8SWjYwknU6T2p3Kef6CQb+/G4pumFxUFG5+tylXa3zKHnNymqecL1KpKvw6K1DKFdA6PcYTh8kEskcV9vb3aa+Uv2Z5pbSlDtHGc3Rdx7PddODK5sIPcL0Iw4DRzGE+n6e/2VPLfwD7icw7vI9cZQAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;불리언 연산을 통한 이진법 덧셈&quot; title=&quot;불리언 연산을 통한 이진법 덧셈&quot; src=&quot;/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/fcda8/boolean-add.png&quot; srcSet=&quot;/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/12f09/boolean-add.png 148w,/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/e4a3f/boolean-add.png 295w,/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/fcda8/boolean-add.png 590w,/static/ab9f3bba1fb2e47ac4621c24eb2f9ac2/4b446/boolean-add.png 877w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;위의 과정은 처음 보면 복잡해보일 수 있겠지만 핵심은 간단하다.
바로 각 자릿수에 있는 1을 참으로, 0을 거짓으로 간주하고
각 자릿수의 숫자들에 대해 AND 연산과 XOR 연산을 수행하는 것이다.
이때 &lt;strong&gt;AND 연산 결과는 다음 자릿수에 올림을 적용 여부를 결정하며,&lt;/strong&gt;
&lt;strong&gt;XOR 연산 결과는 해당 자릿수의 값 존재 여부를 결정한다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;혹시 &lt;em&gt;엥? 그냥 더하면 되는 것을 왜 이렇게 작업하는거지?&lt;/em&gt;라는 생각이 드는가?
놀랍게도 뇌가 없는 고철 덩어리들은 그 &lt;em&gt;그냥 더하는 행위&lt;/em&gt;를 할 줄을 모른다.
즉, 인간의 지능으로 수행할 수 있는 작업들을 어떻게 해야
고철 덩어리들이 그럴듯하게 모방할 수 있을지에 대해 고민한 결과가 바로
2진법 체계와 논리연산에 기반을 둔 컴퓨터라고 볼 수 있다.&lt;/p&gt;&lt;p&gt;그리고 이처럼 기계만의 방식으로 각종 작업을 수행하기 위해 사용되는 도구가 바로
컴퓨터의 구성요소인 &lt;strong&gt;회로&lt;/strong&gt; 및 &lt;strong&gt;게이트&lt;/strong&gt;라고 볼 수 있다.&lt;/p&gt;&lt;h2&gt;논리연산의 물리적 구현&lt;/h2&gt;&lt;p&gt;회로(circuit)라는 단어를 들으면 뭔지도 잘 모르겠지만
일단 머리가 갑자기 지끈거리는 것이 정상적인 반응일 것이다.
만일 그렇다면 지금 본인이 있는 방의 전등을 한 번 껐다 켜보자.
그대는 스위치에 물리적인 조작을 가함으로써 회로를 조작한 것이다.
물론 현대 사회의 컴퓨터는 그대가 조작한 스위치에 비해 훨씬 복잡한 구조를 지니고 있다.
해당 게시물에서는 위에서 언급한 내용을 중심으로 이에 대해 아주 가볍게만 다루고자 한다.&lt;/p&gt;&lt;p&gt;앞서 우리는 컴퓨터가 덧셈 작업을 수행하기 위해 XOR 연산과 AND 연산을
활용한다는 점에 대해 이야기하였다.
그렇다면 컴퓨터는 어떠한 물리적 장치를 사용하여 이러한 연산을 수행할 수 있을까?&lt;/p&gt;&lt;p&gt;또한 예를 들어 계산기에 &lt;code&gt;3 + 4&lt;/code&gt;라는 내용을 입력했을 때
우리가 &lt;code&gt;=&lt;/code&gt;를 눌러 실제로 연산을 실행하기 전까지
계산기는 어떻게 3과 4라는 값을 기억할 수 있을까?
그리고 계산이 끝나고 화면에 출력되는 &lt;code&gt;7&lt;/code&gt;이라는 값은 어떻게 그대로 유지될 수 있을까?&lt;/p&gt;&lt;h3&gt;게이트와 플립플롭&lt;/h3&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/5ae9e4bc74b9997000840acee978d0ac/63a68/logic-gate.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:51.35135135135135%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABV0lEQVQoz3VSXW+CQBDk//8l+1RN6kMLmgpaEoFDqEbxW0FBmGbWHAVtNyF73M3Nzc6uUVUVGN9xhP5bH6ZlIc8L2eOZPmeejB2Y1gDN0BiNM/Qi8D10u68YDIdIswzX67UG3S+WsEefeP8w5Z/neZ4/kRtclGUpG0mSYLvdYrVaYb/f43g84nK5IE3T+lIYhoKLokjy6XQSnMYYTbmWZcHzPCFlLJdLzOdzbDabmtA0TcxmM6zXa8GRlLjD4XAn1FIZ5/NZPhLwy7KsJirLO4ZKbrebEO12uwdbql8PWcpkMoYKFZqPNCsIlYJt2wiC4M/GiELtn22P0Hnp4Mt1/+0gy+32enDGzhNhqylN2QyW2vTt0RY2ik2hh1qQzq2m0GillGR6NJ1OEcdxa4SokiUTx0ngRBCjBbQUFkUhl3m4WCxECdVyX2N835cuu64rj1Ix51F7+AN7BgIfT1w+mwAAAABJRU5ErkJggg==&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;논리 게이트&quot; title=&quot;논리 게이트&quot; src=&quot;/static/5ae9e4bc74b9997000840acee978d0ac/fcda8/logic-gate.png&quot; srcSet=&quot;/static/5ae9e4bc74b9997000840acee978d0ac/12f09/logic-gate.png 148w,/static/5ae9e4bc74b9997000840acee978d0ac/e4a3f/logic-gate.png 295w,/static/5ae9e4bc74b9997000840acee978d0ac/fcda8/logic-gate.png 590w,/static/5ae9e4bc74b9997000840acee978d0ac/63a68/logic-gate.png 629w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;논리 게이트(logic gate)란 입력 값들에 대해
일정한 불리언 연산을 수행한 결과를 출력하는 장치라고 볼 수 있다.
릴리에, 진공관, 트랜지스터, 집적회로 등 다양한 기술을 이용하여 구현될 수 있으며,
기본적으로 전압 수준에 따라 1 혹은 0을 나타내는 전자회로로 구성된다.
그리고 이러한 게이트가 기본 단위로 모여
더욱 구체적인 기능을 하는 회로를 구성하게 된다.
그러한 회로 중 하나가 바로 컴퓨터 메모리의 기본 단위가 되는
플립플롭(flip-flop) 회로다.&lt;/p&gt;&lt;p&gt;플립플롭 회로는 다양한 구조를 띠지만 기본 원리는 자체는 간단하다.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;출력 값으로 0 혹은 1의 값을 꾸준히 유지한다.&lt;/li&gt;&lt;li&gt;특정 위치에 특정한 입력값이 &lt;strong&gt;순간적으로&lt;/strong&gt; 들어오는 경우 출력값은 변화한다.&lt;/li&gt;&lt;li&gt;입력값이 다시 기존으로 돌아가더라도 &lt;strong&gt;변화한 출력값은 그대로 유지된다.&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;이해를 위해 매우 간단한 플립플롭 구조를 가져와보았다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/5e44e90a71d57e2ba0dad4abd8ce1870/bb3ba/flip-flop-example.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:33.78378378378378%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABL0lEQVQoz2WR646CMBCFff9nWxP/yKUCLRWLgAa5Cg3lmBkXN7s7SUNnOPNl5nSHPzEMAx+KxTn0Q495nn9ppnnGbO0nt9Z+NLuu63A6nWCMQV3XaJsGWimIIECRpoijiGtSSj63qsLteoWKIgRhiPv9DmMu/GVg3/fY77+gtcbhcOBimqYMLI2BlhKrtfwvy3Mcj0dM44iyKOD7PpRS8DyP+9Z1xW6aJvieByEEQynyPIfWKYJQoCpLOOeg4hjd+YwwDFmTZRnOlAuBoih+gHSh/auq4pW2eD6fuNJqSr19It/6gYGbX6Qh8DYIA8nDJEl4zQ1IU8VxzBOQt8uyvPNLhiiK+BHIMymT/0ASPx41mqbhRp54mviBxnHE6hyv3LYta+z365JVBKX61kfAF+7FEsGyAlZhAAAAAElFTkSuQmCC&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;플립플롭&quot; title=&quot;플립플롭&quot; src=&quot;/static/5e44e90a71d57e2ba0dad4abd8ce1870/fcda8/flip-flop-example.png&quot; srcSet=&quot;/static/5e44e90a71d57e2ba0dad4abd8ce1870/12f09/flip-flop-example.png 148w,/static/5e44e90a71d57e2ba0dad4abd8ce1870/e4a3f/flip-flop-example.png 295w,/static/5e44e90a71d57e2ba0dad4abd8ce1870/fcda8/flip-flop-example.png 590w,/static/5e44e90a71d57e2ba0dad4abd8ce1870/efc66/flip-flop-example.png 885w,/static/5e44e90a71d57e2ba0dad4abd8ce1870/bb3ba/flip-flop-example.png 1121w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;해당 플립플롭에서 두 입력값이 모두 0일 때 출력값은 0으로 유지된다.
위쪽의 입력값이 순간적으로 1로 변하면 출력값은 1로 변하게 되는데,
이때 변한 출력값은 입력값이 다시 0으로 되돌아가더라도 그대로 유지된다는 특성을 띤다.
즉, 입력값 중 하나가 순간적으로 &lt;code&gt;0-&amp;gt;1-&amp;gt;0&lt;/code&gt;로 깜빡임으로써 &lt;em&gt;디폴트 출력값&lt;/em&gt;이 &lt;code&gt;0-&amp;gt;1&lt;/code&gt;로 변했다는 것이다.&lt;/p&gt;&lt;p&gt;바로 이러한 성질을 활용함으로써 우리는 비트 단위의 데이터를
회로 구조상 특정 물리적인 위치에 &lt;em&gt;얼려놓을&lt;/em&gt; 수 있게 된다.
그리고 이처럼 저장해놓은 데이터를 우리는 보다 복잡한 연산의 입력값으로 사용하고,
해당 연산의 출력값을 다시 다른 위치에 저장해놓을 수 있다.
이는 마치 인간의 뇌의 작업기억(working memory)에서 각종 정보를 실시간으로 관리하고
별도의 작업에 활용하는 것과 마찬가지이다.&lt;/p&gt;&lt;h3&gt;가산기&lt;/h3&gt;&lt;p&gt;그렇다면 플립플롭 회로와 같은 방식으로 저장된 데이터를 활용하여
실제로 어떻게 덧셈 연산을 수행할 수 있을까?
아래는 반가산기(half adder)와 전가산기(full adder)의 기본 구조다.
이때 출력값의 Carry는 올림 여부를, Sum은 특정 자릿수에 실제로 저장하는 값을 의미한다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position:relative;display:block;margin-left:auto;margin-right:auto;max-width:590px&quot;&gt;
      &lt;a class=&quot;gatsby-resp-image-link&quot; href=&quot;/static/21c0cedd0264d1e5073835cf35a8b19e/33e10/adders.png&quot; style=&quot;display:block&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
    &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom:35.810810810810814%;position:relative;bottom:0;left:0;background-image:url(&amp;#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA9UlEQVQoz4VRy26EMBDj//9re15uIBAIOBDCM7zfrjxqqu4etpZGIYnHYwcHH3Df90sR13Vh33dM04TzPGVv7wiHGxKO48CyLOi6DsMwvJDYpJRCmqZwXRdxHMP3fTRNgzAMUSglPeSJoDEGfd/j6/EQQtu2KIpCGqwwzyjkPl1EUYQgCJDnufTSCN2S6/yNmGUZkiRBVVWytySLcRxlYF3XMrAsS8zzLAl/I9MmD+nA8zwpxitLLQIW27YhS1MZxiKHDhld6wK9MSIskWmZgnay+bnku1rwm4601rIyCbnrusoddeQN8Q9sZK5Mwrfmj2NR7B3fZssbqHDSYj4AAAAASUVORK5CYII=&amp;#x27;);background-size:cover;display:block&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;반가산기와 전가산기&quot; title=&quot;반가산기와 전가산기&quot; src=&quot;/static/21c0cedd0264d1e5073835cf35a8b19e/fcda8/adders.png&quot; srcSet=&quot;/static/21c0cedd0264d1e5073835cf35a8b19e/12f09/adders.png 148w,/static/21c0cedd0264d1e5073835cf35a8b19e/e4a3f/adders.png 295w,/static/21c0cedd0264d1e5073835cf35a8b19e/fcda8/adders.png 590w,/static/21c0cedd0264d1e5073835cf35a8b19e/33e10/adders.png 844w&quot; sizes=&quot;(max-width: 590px) 100vw, 590px&quot; style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;좌측의 반가산기의 구조는 이해하기 쉬울 것이다.
각 자릿수의 입력값 두 개를 받아
AND 연산 결과로 올림 여부를 결정하고,
XOR 연산 결과를 해당 자릿수의 값으로 저장한다는
위에서 설명한 불리언 연산을 통해 덧셈 작업의 핵심 원리에 정확히 대응된다.
그런데 반가산기는 오직 2&lt;sup&gt;0&lt;/sup&gt; 자리에서의 연산에만 사용이 가능하다.
2&lt;sup&gt;1&lt;/sup&gt; 자리부터는 바로 아래 자릿수에서 올림 여부가 결정되었는지를 고려해야 하기 때문이다.
즉, 2&lt;sup&gt;1&lt;/sup&gt; 자리부터는 각 자릿수의 입력값 두 개만이 아니라 올림 여부까지 포함하여
총 3가지의 입력값을 받아 처리해야 하며, 우측의 전가산기를 통해 이러한 연산을 처리할 수 있게 된다.&lt;/p&gt;&lt;p&gt;실제 컴퓨터에 들어가는 칩(chip) 하나 하나는
초고밀도 집적회로(VLSI) 기술을 통해 이처럼 다양하고 세부적인 구성을 띤 수백만 개의 회로로 구성된다.&lt;/p&gt;&lt;h2&gt;맺으며&lt;/h2&gt;&lt;p&gt;해당 게시글은 최대한 다양한 주제를 겉핥기식으로 다루고 있다.
그러나 전달하고자 하는 핵심은 간단하다.
컴퓨터와 프로그래밍 언어는 전부 인간이 특정한 의도를 지니고 만들어낸 것이며,
컴퓨터는 복잡하지만 체계적으로 설계된 &lt;strong&gt;물리적인 도구&lt;/strong&gt;라는 것이다.&lt;/p&gt;&lt;p&gt;그리고 논리연산의 결과와 비트에 담기는 데이터가 참/거짓 혹은
1/0와 같이 두 가지 값으로 구분된다는 점은
우연의 일치가 아니라 바로 컴퓨터의 구조에 대해
옅볼 수 있는 중요한 힌트라고 볼 수 있다.&lt;/p&gt;&lt;p&gt;보다 체계적이고 깊이 있는 지식을 원한다면 컴퓨터 구조에 관한
서적을 찾아보는 것을 권장한다.&lt;/p&gt;&lt;hr/&gt;&lt;div&gt;참고문서&lt;/div&gt;&lt;ul&gt;&lt;li&gt;컴퓨터 과학 총론: &lt;a href=&quot;https://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788993712629&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;&lt;li&gt;한 권으로 읽는 컴퓨터 구조와 프로그래밍: &lt;a href=&quot;https://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9791189909284&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[개발 블로그를 시작하며]]></title><description><![CDATA[블로그 버전 1의 개발을 완료하였다. 10일 정도 작업을 하였고 현재 도메인을 구글과 네이버에 각각 등록한 상황이다. 수정 및 추가하고 싶은 기능들이 아직도 꾸준히 생겨나고 있으나 이대로는 끝이 없을 듯 하여 일단 나의 첫 글을 남기고자 한다.]]></description><link>https://bugoverdose.github.io/essay/starting-a-dev-blog/</link><guid isPermaLink="false">https://bugoverdose.github.io/essay/starting-a-dev-blog/</guid><pubDate>Wed, 05 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;지난 해 12월 23일에 깃헙에 저장소를 생성한 이후 올해 1월 4일을 기준으로
블로그 v1.0.0을 완료하였다.
실질적으로 약 10일 정도 작업을 하였고,
&lt;code&gt;github.io&lt;/code&gt; 도메인으로 현재 구글과 네이버에 각각 등록한 상황이다.&lt;/p&gt;&lt;p&gt;수정 및 추가하고 싶은 기능들이 아직도 꾸준히 생겨나고 있으나
이대로는 끝이 없을 듯 하여 일단 나의 첫 글을 남기고자 한다.&lt;/p&gt;&lt;h2&gt;나는 왜 블로그를 시작하였는가&lt;/h2&gt;&lt;p&gt;나는 온라인에 글을 올리는 취미가 딱히 없는 사람이다.
트위터 등 SNS에 글을 올리는 사람들의 심리도 이해는 되지만 딱히 공감하지는 않는다.&lt;/p&gt;&lt;p&gt;다만, 나는 공부한 내용을 체계적으로 정리하는 작업을 대학생활 동안 꾸준히 해왔다.
동일한 내용도 나만의 언어로 다시 한번 정리함으로써
기존에 알던 정보들과 새로운 지식들이 통합되고
특정 주제에 대해 보다 깊이 있는 이해가 가능해지기 때문이다.&lt;/p&gt;&lt;p&gt;2020년부터는 프로그래밍과 관련하여 공부한 것들을 텍스트 파일 및 마크다운 파일로 정리하고
&lt;code&gt;~-study-note&lt;/code&gt;라는 명칭의 깃헙 저장소들에서 관리하기 시작하였다.
그러나 시간이 지난 후, 몇 달 전에 내가 열심히 정리한 글들을 다시 보았을 때
도저히 내용을 이해할 수가 없다는 문제가 확인되었다.
이 때문에 현재는 대부분의 저장소들을 private으로 바꾼 상태이다.
이 상황에 대해 고민해본 결과, 해당 글들이 타인이 읽는 것을 염두에 두지 않고
작성되었기 때문에 가독성이 낮은 것이라는 결론에 도달하였다.
해당 저장소들에 별을 주신 분들도
내가 작성해놓은 내용들을 실제로 읽고 있지는 않을 것이라고 생각한다.&lt;/p&gt;&lt;p&gt;때문에 나는 앞으로 내가 공부한 내용들을 독자를 염두에 두고 정리하고자 하며,
이를 위해 실제로 독자가 존재하는 환경에 글을 올리고자 한다.&lt;/p&gt;&lt;h2&gt;나는 왜 블로그를 직접 개발하였는가&lt;/h2&gt;&lt;p&gt;사실 단순히 글을 올릴 수 있는 환경은 참 많다. SNS나 네이버 블로그 외에도
개발 블로그에 특화된 플랫폼들도 꽤 존재하는 것으로 안다.
특히 &lt;a href=&quot;https://velog.io/&quot;&gt;벨로그&lt;/a&gt;를 사용하면 이미 훌륭하게 개발된 템플릿을 토대로
글을 쓰는 작업에 온전히 몰두할 수 있으며
보다 많은 사람들에게 내가 작성한 글이 전달될 것이라고 생각한다.&lt;/p&gt;&lt;p&gt;그러나 나의 주변 사람들 중에는 &lt;code&gt;gatsby-starter-bee&lt;/code&gt;&lt;div num=&quot;1&quot;&gt;&lt;/div&gt;
혹은 &lt;code&gt;gatsby-starter-blog&lt;/code&gt;&lt;div num=&quot;2&quot;&gt;&lt;/div&gt;
와 같은 템플릿을 활용하여 개발 블로그를 만든 사람들이 상당히 많다.
그들이 있었기 때문에 나도 당연히 Gatsby로 직접 개발 및 배포해야 한다고 생각했었고
종강하자마자 바로 공식 사이트의 튜토리얼을 읽기 시작하였다.&lt;/p&gt;&lt;h2&gt;나는 왜 템플릿을 사용하지 않았는가&lt;/h2&gt;&lt;p&gt;다만 나의 경우 템플릿을 사용하지 않고 &lt;code&gt;gatsby new&lt;/code&gt;를 실행하여 만들어지는
디폴트 프로젝트를 기반으로 필요에 따라 플러그인들을 하나하나
설치 및 설정해나가면서 개발을 진행하였다.
디자인의 경우에도 &lt;code&gt;gatsby-plugin-styled-components&lt;/code&gt;를 설치한 이후,
프로젝트 전체에 reset css를 먹이고 컴포넌트별로
css 속성들을 전부 하나 하나 작성하면서 디자인해나갔다.&lt;/p&gt;&lt;p&gt;수많은 템플릿이 존재한다는 점이 개츠비의 장점 중 하나인데
내가 왜 굳이 이처럼 제로베이스에서 시작하였는지에 대해 한번 설명하고자 한다.&lt;/p&gt;&lt;h3&gt;가오&lt;/h3&gt;&lt;p&gt;첫째는 당연히 가오 때문이다. 이것은 무척 중요하다.
현재 나는 굳이 따지자면 백엔드로 분류되지만
일단은 웹 프론트엔드로 소프트웨어 개발에 입문한 사람이다.
내가 하나부터 열까지 전부 직접 구현할 수 있는데 굳이 다른 사람의 코드에 의존하고 싶지 않았다.&lt;/p&gt;&lt;h3&gt;공부&lt;/h3&gt;&lt;p&gt;둘째는 공부 목적이다.
개발과정에서 SEO(검색엔진 최적화), Open Graph 프로토콜 등 다양한 주제를 공부하고
그 지식을 실제 프로젝트에 적용해볼 기회가 생겨서 무엇보다도 좋았다.
해당 사이트가 활성화되면 Google Analysis 등 다른 도구들도 본격적으로 활용해보고자 한다.&lt;/p&gt;&lt;p&gt;또한 Gatsby에 이번 기회에 입문하였는데 BFF(Backend For Frontend) 프레임워크답게
mdx, yaml, json 파일의 형식으로 자료를 효율적으로 구조화하고
GraphQL 쿼리로 이를 조회하는 경험을 할 수 있어서 굉장히 좋았다.
관계형 데이터베이스와 SQL문이라는 고정된 형식에서 벗어남으로써
백엔드 개발자로서의 전체적인 시야가 더 넓어질 수 있었다고 생각한다.&lt;/p&gt;&lt;h3&gt;통제&lt;/h3&gt;&lt;p&gt;무엇보다도 프로젝트에 대한 통제력을 확보하는 것이 가장 중요한 이유였다.&lt;/p&gt;&lt;p&gt;프로젝트 내에 존재하는 모든 코드에 대해 개발자 본인이 이해를 하고 있어야
각종 기능, 디자인적인 요소, 라우팅 등을 자유자제로 수정 및 추가할 수 있지 않은가.&lt;/p&gt;&lt;p&gt;만일 &lt;code&gt;gatsby-starter-blog&lt;/code&gt;와 같은 탬플릿의 전반적인 디자인과 기능들이
내 마음에 들었다면 해당 탬플릿을 그냥 사용하고 일부 코드만 적절하게 수정하는 것이
가장 효율적이었을지도 모른다.
그러나 해당 템플릿의 디자인과 라우팅은 내 취향에 전혀 맞지 않았다.&lt;/p&gt;&lt;p&gt;탬플릿을 기반으로 코드를 전부 뜯어고칠 바에야
차라리 모든 디자인과 기능을 제로베이스에서 직접 구현하는 것은 당연한 선택지였다고 볼 수 있다.
현재 결과물은 만족스럽고 꾸준한 리팩토링으로 인해 유지보수도 용이하게 관리되고 있다.&lt;/p&gt;&lt;h3&gt;버전 이슈&lt;/h3&gt;&lt;p&gt;나는 현재 릴리즈된 버전들 중 가장 최신인 Gatsby v4.4를 사용하여 프로젝트를 셋업하였다.
물론 버전이라는 것이 높으면 높을수록 무조건 좋은 것만은 아니다.
실제로 &lt;code&gt;gatsby-starter-bee&lt;/code&gt;의 경우
Gatsby v2를 사용하는 올-드한 프로젝트임에도 많은 이들의 사랑을 꾸준히 받고 있다.&lt;/p&gt;&lt;p&gt;그렇지만 Gatsby는 현재 빠른 속도로 발전하는 프레임워크이기 때문에
일단은 최신 버전을 사용하는 것이 유지보수 측면에서 장기적으로 적절하다고 생각한다.
2021년 3월과 10월에 각각 v3.0.0과 v4.0.0이 릴리즈된 것만 보아도
버전 업데이트 속도가 실로 정신나갔다고밖에 말할 수 없다.&lt;/p&gt;&lt;p&gt;Gatsby의 프로젝트 구조 및 플러그인 설정 방법에 대한 이해가 부족한
사람이 별 생각 없이 탬플릿을 사용할 경우,
향후 플러그인 중 하나가 deprecate되거나 버전 마이그레이션이 필요한 상황이 생겼을 때
과연 문제 상황에 원활하게 대처할 수 있을지 솔직히 의구심이 든다.&lt;/p&gt;&lt;h2&gt;나는 어떤 글을 쓸 것인가&lt;/h2&gt;&lt;p&gt;솔직히 잘 모르겠다. 거 뭐 해본적이 있어야지 말이다.
스스로를 &amp;#x27;필자&amp;#x27;라고 지칭해야 할지 &amp;#x27;나&amp;#x27;라고 지칭하는 것이 적절한지도 현재 고민하는 중이다.
전반적으로 문어체를 추구할지 구어체에 가깝게 작성할지도 생각 중이다.&lt;/p&gt;&lt;p&gt;그렇지만 일단 현재 블로그 결과물이 생각보다 잘 나왔고,
이왕 이렇게 된거 한 번 제대로 관리해보고자 한다.
현재 구현해놓은 페이지네이션, 태그 사전 등의 기능이 제대로 동작하려면
적어도 11개 이상의 글은 존재해야 하기 때문에 일단은 뭐라도 쓰기는 할 생각이다.&lt;/p&gt;&lt;h3&gt;글쓰기 윤리에 대하여&lt;/h3&gt;&lt;p&gt;기본적으로 모든 게시글은 개발, 실험 등 개인적인 경험과 독서 내용에 기반을 두고 작성하고자 한다.
다만, 참고자료가 조금이라도 존재할 경우 본문에 최소한의 언급을 하고,
각 게시글 하단에 관련 링크를 추가하고자 한다.&lt;/p&gt;&lt;hr/&gt;&lt;div&gt;&lt;div num=&quot;1&quot;&gt;&lt;p&gt;gatsby-starter-bee: 오픈소스 블로그 탬플릿. &lt;strong&gt;&lt;a href=&quot;https://github.com/JaeYeopHan/gatsby-starter-bee&quot;&gt;깃헙 저장소 링크&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;&lt;div num=&quot;2&quot;&gt;&lt;p&gt;gatsby-starter-blog: Gatsby Starter Library에 등록된 개츠비 공식 블로그 탬플릿. &lt;strong&gt;&lt;a href=&quot;https://www.gatsbyjs.com/starters/gatsbyjs/gatsby-starter-blog/&quot;&gt;공식문서 링크&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded></item></channel></rss>