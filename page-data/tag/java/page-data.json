{
    "componentChunkName": "component---src-templates-tag-js",
    "path": "/tag/java",
    "result": {"data":{"allMdx":{"nodes":[{"frontmatter":{"title":"[C++] 다형성과 가상 함수","description":"C++에서 다형성을 구현하기 위해 필수적으로 알아야 하는 기초 개념 및 문법을 간단히 정리하였습니다. 추가로 Java와의 비교를 통해 가상함수의 필요성을 정리하였습니다.","date":"June 8, 2024","category":"development","tags":["cpp","inheritance","syntax","java"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/235bd275b6e4b3c0be12bec9b2d742d1/12a3e/cpp-polymorphism-and-virtual-function-wide.png","srcSet":"/static/235bd275b6e4b3c0be12bec9b2d742d1/9d9e0/cpp-polymorphism-and-virtual-function-wide.png 225w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/cc174/cpp-polymorphism-and-virtual-function-wide.png 450w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/12a3e/cpp-polymorphism-and-virtual-function-wide.png 900w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/4dd11/cpp-polymorphism-and-virtual-function-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/235bd275b6e4b3c0be12bec9b2d742d1/3f003/cpp-polymorphism-and-virtual-function-wide.webp 225w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/ba134/cpp-polymorphism-and-virtual-function-wide.webp 450w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/e7f7d/cpp-polymorphism-and-virtual-function-wide.webp 900w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/fc420/cpp-polymorphism-and-virtual-function-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"cpp polymorphism and virtual function image"},"id":"a334dea1-745b-55db-999f-3f110318cce0","slug":"development/cpp-polymorphism-and-virtual-function/"},{"frontmatter":{"title":"[Swagger] 인터페이스로 어노테이션 분리하기","description":"스프링에서 스웨거를 활용하다보면 컨트롤러에 각종 스웨거 어노테이션을 추가할 일이 생깁니다. 자바 인터페이스를 활용하여 문서화 관련 어노테이션을 컨트롤러로부터 분리해봅시다.","date":"March 27, 2024","category":"development","tags":["spring","swagger","annotation","java","interface","dev-tools","api"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/bf7f55d67a0f66bd2b00ace418fee239/12a3e/swagger-annotations-with-interface-wide.png","srcSet":"/static/bf7f55d67a0f66bd2b00ace418fee239/9d9e0/swagger-annotations-with-interface-wide.png 225w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/cc174/swagger-annotations-with-interface-wide.png 450w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/12a3e/swagger-annotations-with-interface-wide.png 900w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/4dd11/swagger-annotations-with-interface-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/bf7f55d67a0f66bd2b00ace418fee239/3f003/swagger-annotations-with-interface-wide.webp 225w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/ba134/swagger-annotations-with-interface-wide.webp 450w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/e7f7d/swagger-annotations-with-interface-wide.webp 900w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/fc420/swagger-annotations-with-interface-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"swagger image"},"id":"3aab9e4c-49c4-52cd-9b0f-8afa4b7bb06d","slug":"development/swagger-separate-annotations-with-interface/"},{"frontmatter":{"title":"[OS] 멀티쓰레딩 모델","description":"유저 쓰레드와 OS 쓰레드 간의 관계가 Many-to-One, One-to-One, Many-to-Many일 때 각각 어떠한 차이를 지니는지 압축적으로 정리합니다. 고루틴, 코루틴, 쓰레드풀, 자바의 가상 쓰레드 등의 아키텍처를 이해하는 데 필요한 배경지식을 다룹니다.","date":"October 15, 2023","category":"computer-science","tags":["operating-system","thread","thread-pool","multi-threading","concurrency","java","virtual-thread","go","goroutine"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/9a9ee4c1b7551795a6ccd83fdf99b36f/12a3e/multi-threading-models-wide.png","srcSet":"/static/9a9ee4c1b7551795a6ccd83fdf99b36f/9d9e0/multi-threading-models-wide.png 225w,\n/static/9a9ee4c1b7551795a6ccd83fdf99b36f/cc174/multi-threading-models-wide.png 450w,\n/static/9a9ee4c1b7551795a6ccd83fdf99b36f/12a3e/multi-threading-models-wide.png 900w,\n/static/9a9ee4c1b7551795a6ccd83fdf99b36f/4dd11/multi-threading-models-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/9a9ee4c1b7551795a6ccd83fdf99b36f/3f003/multi-threading-models-wide.webp 225w,\n/static/9a9ee4c1b7551795a6ccd83fdf99b36f/ba134/multi-threading-models-wide.webp 450w,\n/static/9a9ee4c1b7551795a6ccd83fdf99b36f/e7f7d/multi-threading-models-wide.webp 900w,\n/static/9a9ee4c1b7551795a6ccd83fdf99b36f/fc420/multi-threading-models-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"multi threading models image"},"id":"698eb25a-2091-5276-b13d-cb2378ba7232","slug":"computer-science/multi-threading-models/"},{"frontmatter":{"title":"[토이 프로젝트] MyS3: 나만의 작은 이미지 호스팅 서버","description":"AWS S3를 사용할 수 없게 되어 EC2 인스턴스에서 실행가능한 대체품을 만들어보았습니다. 이미지 파일 업로드 및 조회 API를 제공하며, 업로드된 파일을 로컬 머신에서 직접 관리하는 구조입니다.","date":"August 7, 2022","category":"development","tags":["java","project"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/85856f0bf522c0cc6abb8ae80b40652e/12a3e/mys3-wide.png","srcSet":"/static/85856f0bf522c0cc6abb8ae80b40652e/9d9e0/mys3-wide.png 225w,\n/static/85856f0bf522c0cc6abb8ae80b40652e/cc174/mys3-wide.png 450w,\n/static/85856f0bf522c0cc6abb8ae80b40652e/12a3e/mys3-wide.png 900w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/85856f0bf522c0cc6abb8ae80b40652e/3f003/mys3-wide.webp 225w,\n/static/85856f0bf522c0cc6abb8ae80b40652e/ba134/mys3-wide.webp 450w,\n/static/85856f0bf522c0cc6abb8ae80b40652e/e7f7d/mys3-wide.webp 900w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"MyS3 image"},"id":"9c951dfe-90b0-5020-9d36-6ea16a2f52ec","slug":"development/image-hosting-server-toy-project/"},{"frontmatter":{"title":"[Java] 데코레이터 패턴: 구현과 한계","description":"데코레이터 패턴을 통해 특정한 데이터에 대해 일련의 작업을 순차적으로 적용하는 구조를 만들어보자. 그리고 이러한 코드의 한계에 대하여 논해보자. 유연한 코드의 이면에는 구조의 복잡성이 자리잡고 있다.","date":"May 26, 2022","category":"development","tags":["java","decorator-pattern","design-pattern"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#282828","images":{"fallback":{"src":"/static/92b247c93aece14a68001c0de2d469e0/12a3e/decorator-pattern-wide.png","srcSet":"/static/92b247c93aece14a68001c0de2d469e0/9d9e0/decorator-pattern-wide.png 225w,\n/static/92b247c93aece14a68001c0de2d469e0/cc174/decorator-pattern-wide.png 450w,\n/static/92b247c93aece14a68001c0de2d469e0/12a3e/decorator-pattern-wide.png 900w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/92b247c93aece14a68001c0de2d469e0/3f003/decorator-pattern-wide.webp 225w,\n/static/92b247c93aece14a68001c0de2d469e0/ba134/decorator-pattern-wide.webp 450w,\n/static/92b247c93aece14a68001c0de2d469e0/e7f7d/decorator-pattern-wide.webp 900w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"decorator pattern image"},"id":"c9b13bab-4f76-5fe3-852b-52ce33f4edb4","slug":"development/decorator-pattern-implementation-and-limitations/"},{"frontmatter":{"title":"[Java] 어댑터 패턴과 OCP","description":"어댑터 패턴을 통해 외부 라이브러리에 대한 의존성을 도메인으로부터 분리하는 과정을 다룬다. 추상화에 대한 의존과 객체의 사용과 생성의 분리라는 관점에서 OCP에 부합하도록 클라이언트 코드를 리팩토링해보자.","date":"May 25, 2022","category":"development","tags":["java","adapter","design-pattern","ocp"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#282828","images":{"fallback":{"src":"/static/386828e1664f43a583c6ae4b70a678fc/12a3e/adapter-pattern-wide.png","srcSet":"/static/386828e1664f43a583c6ae4b70a678fc/9d9e0/adapter-pattern-wide.png 225w,\n/static/386828e1664f43a583c6ae4b70a678fc/cc174/adapter-pattern-wide.png 450w,\n/static/386828e1664f43a583c6ae4b70a678fc/12a3e/adapter-pattern-wide.png 900w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/386828e1664f43a583c6ae4b70a678fc/3f003/adapter-pattern-wide.webp 225w,\n/static/386828e1664f43a583c6ae4b70a678fc/ba134/adapter-pattern-wide.webp 450w,\n/static/386828e1664f43a583c6ae4b70a678fc/e7f7d/adapter-pattern-wide.webp 900w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"adapter pattern image"},"id":"9f8b3080-ccce-59ad-af78-88f90d17b374","slug":"development/adapter-pattern-and-ocp/"},{"frontmatter":{"title":"[Java] JGraphT 라이브러리를 통한 최단경로 조회","description":"해당 게시글은 jgrapht 라이브러리를 활용하는 다양한 방법에 대한 예시 코드를 제공한다. 특히 기존 도메인을 수정하지 않고 최단경로를 구간들의 목록으로 반환받는 방법에 대한 탐구 과정을 단계별로 정리하였다.","date":"May 24, 2022","category":"development","tags":["java","jgrapht","algorithm","proxy","dijkstra"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/5e50e0a8f4a1c7580f11aa380feb0308/12a3e/jgrapht-wide.png","srcSet":"/static/5e50e0a8f4a1c7580f11aa380feb0308/9d9e0/jgrapht-wide.png 225w,\n/static/5e50e0a8f4a1c7580f11aa380feb0308/cc174/jgrapht-wide.png 450w,\n/static/5e50e0a8f4a1c7580f11aa380feb0308/12a3e/jgrapht-wide.png 900w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/5e50e0a8f4a1c7580f11aa380feb0308/3f003/jgrapht-wide.webp 225w,\n/static/5e50e0a8f4a1c7580f11aa380feb0308/ba134/jgrapht-wide.webp 450w,\n/static/5e50e0a8f4a1c7580f11aa380feb0308/e7f7d/jgrapht-wide.webp 900w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"jgrapht image"},"id":"f390eb87-c39d-5091-89d3-606513f0def8","slug":"development/finding-shortest-path-with-jgrapht/"},{"frontmatter":{"title":"[Java] 스트림: 지연 연산과 최적화","description":"Stream API의 주요 특성인 지연 연산의 의미, 그리고 이를 기반으로 일어나는 루프퓨전과 쇼트서킷에 대해 알아보자. Stream API가 스트림이라고 불릴 수 있는 원인이 바로 여기에 있는 것으로 보인다.","date":"April 13, 2022","category":"development","tags":["java","modern-java","stream","lazy","short-circuit"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/4ec343a30ea3d448be1f1cc966c7efbe/12a3e/lazy-stream-wide.png","srcSet":"/static/4ec343a30ea3d448be1f1cc966c7efbe/9d9e0/lazy-stream-wide.png 225w,\n/static/4ec343a30ea3d448be1f1cc966c7efbe/cc174/lazy-stream-wide.png 450w,\n/static/4ec343a30ea3d448be1f1cc966c7efbe/12a3e/lazy-stream-wide.png 900w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/4ec343a30ea3d448be1f1cc966c7efbe/3f003/lazy-stream-wide.webp 225w,\n/static/4ec343a30ea3d448be1f1cc966c7efbe/ba134/lazy-stream-wide.webp 450w,\n/static/4ec343a30ea3d448be1f1cc966c7efbe/e7f7d/lazy-stream-wide.webp 900w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"lazy stream image"},"id":"b2d9b6b1-1451-572f-be95-5668ca721bdc","slug":"development/stream-lazy-evaluation/"},{"frontmatter":{"title":"[Java] 스트림 연산의 분류","description":"스트림 파이프라인은 중간연산과 최종연산으로 구성된다. 스트림 연산은 다시 내부적으로 관리되는 상태의 유무와 상태의 크기에 따라서도 구분된다. 이러한 분류는 Stream API의 내부 동작을 이해하는 데 도움이 된다.","date":"April 11, 2022","category":"development","tags":["java","stream","modern-java"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/017d1b3e02bc8ee806df0a3ed73ae93f/12a3e/stream-operations-wide.png","srcSet":"/static/017d1b3e02bc8ee806df0a3ed73ae93f/9d9e0/stream-operations-wide.png 225w,\n/static/017d1b3e02bc8ee806df0a3ed73ae93f/cc174/stream-operations-wide.png 450w,\n/static/017d1b3e02bc8ee806df0a3ed73ae93f/12a3e/stream-operations-wide.png 900w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/017d1b3e02bc8ee806df0a3ed73ae93f/3f003/stream-operations-wide.webp 225w,\n/static/017d1b3e02bc8ee806df0a3ed73ae93f/ba134/stream-operations-wide.webp 450w,\n/static/017d1b3e02bc8ee806df0a3ed73ae93f/e7f7d/stream-operations-wide.webp 900w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"stream operations image"},"id":"3be77123-906e-5c04-bdf7-f53661826dc8","slug":"development/stream-operations/"},{"frontmatter":{"title":"[Java] 값 객체: 동등성과 동일성","description":"동등성과 동일성 개념을 토대로 값과 객체를 비교해보고, 값 객체에 대해 이해해보자. 로또 번호와 위치 정보를 값 객체로 구현해보고, 체스말의 이동경로 검증 예시를 통해 값 객체가 지니는 이점에 대해 알아보자.","date":"April 9, 2022","category":"development","tags":["java","value-object","object","oop"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/7b7817b3ed441a4700ba4673be9e260a/12a3e/value-object-wide.png","srcSet":"/static/7b7817b3ed441a4700ba4673be9e260a/9d9e0/value-object-wide.png 225w,\n/static/7b7817b3ed441a4700ba4673be9e260a/cc174/value-object-wide.png 450w,\n/static/7b7817b3ed441a4700ba4673be9e260a/12a3e/value-object-wide.png 900w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/7b7817b3ed441a4700ba4673be9e260a/3f003/value-object-wide.webp 225w,\n/static/7b7817b3ed441a4700ba4673be9e260a/ba134/value-object-wide.webp 450w,\n/static/7b7817b3ed441a4700ba4673be9e260a/e7f7d/value-object-wide.webp 900w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"value object image"},"id":"ada49ef6-4774-589e-99bc-5a96cd5cef07","slug":"development/value-object/"}],"pageInfo":{"currentPage":1,"hasNextPage":true,"hasPreviousPage":false,"pageCount":2,"totalCount":13}}},"pageContext":{"slug":"java","ko":"자바","skip":0}},
    "staticQueryHashes": ["1903006949","2193720160"]}