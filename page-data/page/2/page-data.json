{
    "componentChunkName": "component---src-templates-home-js",
    "path": "/page/2",
    "result": {"data":{"allMdx":{"nodes":[{"frontmatter":{"title":"[C++] const 키워드의 활용","description":"C언어에서의 const 키워드를 가볍게 복습하고, const 객체, const 함수, const 매개변수, const 반환형, 형 변환 연산자 const_cast, mutable 키워드 등에 대해 포괄적으로 정리하겠습니다.","date":"June 20, 2024","category":"development","tags":["cpp","const-keyword","mutable-keyword","const-cast","copy-constructor","pointer","class","syntax"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/8b2e600740f199c315237a5518ecca9f/12a3e/cpp-const-keyword-wide.png","srcSet":"/static/8b2e600740f199c315237a5518ecca9f/9d9e0/cpp-const-keyword-wide.png 225w,\n/static/8b2e600740f199c315237a5518ecca9f/cc174/cpp-const-keyword-wide.png 450w,\n/static/8b2e600740f199c315237a5518ecca9f/12a3e/cpp-const-keyword-wide.png 900w,\n/static/8b2e600740f199c315237a5518ecca9f/4dd11/cpp-const-keyword-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/8b2e600740f199c315237a5518ecca9f/3f003/cpp-const-keyword-wide.webp 225w,\n/static/8b2e600740f199c315237a5518ecca9f/ba134/cpp-const-keyword-wide.webp 450w,\n/static/8b2e600740f199c315237a5518ecca9f/e7f7d/cpp-const-keyword-wide.webp 900w,\n/static/8b2e600740f199c315237a5518ecca9f/fc420/cpp-const-keyword-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"cpp const keyword image"},"id":"861b3f18-4888-5239-8e9f-edfd2913a69b","slug":"development/cpp-const-keyword/"},{"frontmatter":{"title":"[리뷰] 윤성우의 열혈 C++ 프로그래밍 독후감","description":"지인으로부터 선물받은 윤성우의 열혈 C++ 프로그래밍이라는 서적을 완독하였습니다. 책에 대한 짧은 후기를 남기고자 합니다.","date":"June 19, 2024","category":"essay","tags":["book-review","cpp","syntax"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/94e8dae09968ffa6ac6c0dcc0d524831/12a3e/passionate-cpp-book-review-wide.png","srcSet":"/static/94e8dae09968ffa6ac6c0dcc0d524831/9d9e0/passionate-cpp-book-review-wide.png 225w,\n/static/94e8dae09968ffa6ac6c0dcc0d524831/cc174/passionate-cpp-book-review-wide.png 450w,\n/static/94e8dae09968ffa6ac6c0dcc0d524831/12a3e/passionate-cpp-book-review-wide.png 900w,\n/static/94e8dae09968ffa6ac6c0dcc0d524831/4dd11/passionate-cpp-book-review-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/94e8dae09968ffa6ac6c0dcc0d524831/3f003/passionate-cpp-book-review-wide.webp 225w,\n/static/94e8dae09968ffa6ac6c0dcc0d524831/ba134/passionate-cpp-book-review-wide.webp 450w,\n/static/94e8dae09968ffa6ac6c0dcc0d524831/e7f7d/passionate-cpp-book-review-wide.webp 900w,\n/static/94e8dae09968ffa6ac6c0dcc0d524831/fc420/passionate-cpp-book-review-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"passionate cpp book review image"},"id":"e5fe77ba-f0d1-5376-a042-2ca2ebf0cd9b","slug":"essay/passionate-cpp-book-review/"},{"frontmatter":{"title":"[C++] 가상 소멸자와 메모리 누수","description":"소멸자 문법에 대해 간략히 정리하고 소멸자를 통해 메모리 누수를 방지하는 방법에 대해 알아봅니다. 상속 문법의 경우 최상위 클래스에 가상 소멸자를 정의해야 하는 경우와 필요성에 대해 정리해봅니다.","date":"June 9, 2024","category":"development","tags":["cpp","destructor","virtual-keyword","virtual-destructor","memory-leak","syntax"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/90bcfbb4028bb5d2db8b5ecb38fedec5/12a3e/cpp-destructor-and-memory-leak-wide.png","srcSet":"/static/90bcfbb4028bb5d2db8b5ecb38fedec5/9d9e0/cpp-destructor-and-memory-leak-wide.png 225w,\n/static/90bcfbb4028bb5d2db8b5ecb38fedec5/cc174/cpp-destructor-and-memory-leak-wide.png 450w,\n/static/90bcfbb4028bb5d2db8b5ecb38fedec5/12a3e/cpp-destructor-and-memory-leak-wide.png 900w,\n/static/90bcfbb4028bb5d2db8b5ecb38fedec5/4dd11/cpp-destructor-and-memory-leak-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/90bcfbb4028bb5d2db8b5ecb38fedec5/3f003/cpp-destructor-and-memory-leak-wide.webp 225w,\n/static/90bcfbb4028bb5d2db8b5ecb38fedec5/ba134/cpp-destructor-and-memory-leak-wide.webp 450w,\n/static/90bcfbb4028bb5d2db8b5ecb38fedec5/e7f7d/cpp-destructor-and-memory-leak-wide.webp 900w,\n/static/90bcfbb4028bb5d2db8b5ecb38fedec5/fc420/cpp-destructor-and-memory-leak-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"cpp destructor and memory leak image"},"id":"be99e8cc-613a-57e8-912a-43b9b53fc961","slug":"development/cpp-destructor-and-memory-leak/"},{"frontmatter":{"title":"[C++] 다형성과 가상 함수","description":"C++에서 다형성을 구현하기 위해 필수적으로 알아야 하는 기초 개념 및 문법을 간단히 정리하였습니다. 추가로 Java와의 비교를 통해 가상함수의 필요성을 정리하였습니다.","date":"June 8, 2024","category":"development","tags":["cpp","polymorphism","polymorphic-class","virtual-function","virtual-keyword","syntax","java"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/235bd275b6e4b3c0be12bec9b2d742d1/12a3e/cpp-polymorphism-and-virtual-function-wide.png","srcSet":"/static/235bd275b6e4b3c0be12bec9b2d742d1/9d9e0/cpp-polymorphism-and-virtual-function-wide.png 225w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/cc174/cpp-polymorphism-and-virtual-function-wide.png 450w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/12a3e/cpp-polymorphism-and-virtual-function-wide.png 900w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/4dd11/cpp-polymorphism-and-virtual-function-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/235bd275b6e4b3c0be12bec9b2d742d1/3f003/cpp-polymorphism-and-virtual-function-wide.webp 225w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/ba134/cpp-polymorphism-and-virtual-function-wide.webp 450w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/e7f7d/cpp-polymorphism-and-virtual-function-wide.webp 900w,\n/static/235bd275b6e4b3c0be12bec9b2d742d1/fc420/cpp-polymorphism-and-virtual-function-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"cpp polymorphism and virtual function image"},"id":"a334dea1-745b-55db-999f-3f110318cce0","slug":"development/cpp-polymorphism-and-virtual-function/"},{"frontmatter":{"title":"[C++] 접근제어자와 상속","description":"C++에서는 상위클래스의 멤버들을 상속받을 때 접근제어자를 변형시킬 수 있는 문법을 제공합니다. 접근제어자들에 대해 가볍게 다루고, public 상속, protected 상속, private 상속에 대해 정리해보겠습니다.","date":"June 8, 2024","category":"development","tags":["cpp","access-modifier","public-keyword","protected-keyword","private-keyword","inheritance","syntax"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/20e762b9d09e6ba2ad7ce65c6f144813/12a3e/cpp-access-modifier-and-inheritance-wide.png","srcSet":"/static/20e762b9d09e6ba2ad7ce65c6f144813/9d9e0/cpp-access-modifier-and-inheritance-wide.png 225w,\n/static/20e762b9d09e6ba2ad7ce65c6f144813/cc174/cpp-access-modifier-and-inheritance-wide.png 450w,\n/static/20e762b9d09e6ba2ad7ce65c6f144813/12a3e/cpp-access-modifier-and-inheritance-wide.png 900w,\n/static/20e762b9d09e6ba2ad7ce65c6f144813/4dd11/cpp-access-modifier-and-inheritance-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/20e762b9d09e6ba2ad7ce65c6f144813/3f003/cpp-access-modifier-and-inheritance-wide.webp 225w,\n/static/20e762b9d09e6ba2ad7ce65c6f144813/ba134/cpp-access-modifier-and-inheritance-wide.webp 450w,\n/static/20e762b9d09e6ba2ad7ce65c6f144813/e7f7d/cpp-access-modifier-and-inheritance-wide.webp 900w,\n/static/20e762b9d09e6ba2ad7ce65c6f144813/fc420/cpp-access-modifier-and-inheritance-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"cpp access modifier and inheritance image"},"id":"37d98096-52c5-514f-a340-6d1806f80e49","slug":"development/cpp-access-modifier-and-inheritance/"},{"frontmatter":{"title":"[C++] 복사 생성자 문법","description":"C++의 복사 생성자는 매개변수로 같은 타입의 객체를 넘겨받고 그 내용을 복사하여 생성하는 생성자입니다. 복사 생성자의 호출 시점, 디폴트 복사 생성자, 얕은 복사와 깊은 복사, explicit 키워드에 대해 정리하겠습니다.","date":"May 28, 2024","category":"development","tags":["cpp","copy-constructor","explicit-keyword","shallow-copy","deep-copy","syntax"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/2f86c9d2a7d8fbc75d1df79e1f68ea22/12a3e/cpp-copy-constructor-syntax-wide.png","srcSet":"/static/2f86c9d2a7d8fbc75d1df79e1f68ea22/9d9e0/cpp-copy-constructor-syntax-wide.png 225w,\n/static/2f86c9d2a7d8fbc75d1df79e1f68ea22/cc174/cpp-copy-constructor-syntax-wide.png 450w,\n/static/2f86c9d2a7d8fbc75d1df79e1f68ea22/12a3e/cpp-copy-constructor-syntax-wide.png 900w,\n/static/2f86c9d2a7d8fbc75d1df79e1f68ea22/4dd11/cpp-copy-constructor-syntax-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/2f86c9d2a7d8fbc75d1df79e1f68ea22/3f003/cpp-copy-constructor-syntax-wide.webp 225w,\n/static/2f86c9d2a7d8fbc75d1df79e1f68ea22/ba134/cpp-copy-constructor-syntax-wide.webp 450w,\n/static/2f86c9d2a7d8fbc75d1df79e1f68ea22/e7f7d/cpp-copy-constructor-syntax-wide.webp 900w,\n/static/2f86c9d2a7d8fbc75d1df79e1f68ea22/fc420/cpp-copy-constructor-syntax-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"cpp copy constructor syntax image"},"id":"6c5c012b-2304-5a29-a9e9-dcb1f44c4d99","slug":"development/cpp-copy-constructor-syntax/"},{"frontmatter":{"title":"[C++] 참조자 문법 정리","description":"C++에서 참조자는 특정 변수가 가리키는 메모리 공간을 가리키는 또 하나의 식별자를 생성하는 문법입니다. 포인터와의 차이점, const 참조자, 선언 가능 범위, 매개변수 및 반환형 위치의 참조자 등에 대해 정리해보고자 합니다.","date":"May 6, 2024","category":"development","tags":["cpp","reference-syntax","syntax"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/862b00f9989397b428b1f96cb697dc8a/12a3e/cpp-reference-syntax-wide.png","srcSet":"/static/862b00f9989397b428b1f96cb697dc8a/9d9e0/cpp-reference-syntax-wide.png 225w,\n/static/862b00f9989397b428b1f96cb697dc8a/cc174/cpp-reference-syntax-wide.png 450w,\n/static/862b00f9989397b428b1f96cb697dc8a/12a3e/cpp-reference-syntax-wide.png 900w,\n/static/862b00f9989397b428b1f96cb697dc8a/4dd11/cpp-reference-syntax-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/862b00f9989397b428b1f96cb697dc8a/3f003/cpp-reference-syntax-wide.webp 225w,\n/static/862b00f9989397b428b1f96cb697dc8a/ba134/cpp-reference-syntax-wide.webp 450w,\n/static/862b00f9989397b428b1f96cb697dc8a/e7f7d/cpp-reference-syntax-wide.webp 900w,\n/static/862b00f9989397b428b1f96cb697dc8a/fc420/cpp-reference-syntax-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"cpp reference syntax image"},"id":"c89d17a4-48db-556d-8da1-b6662b3a129a","slug":"development/cpp-reference-syntax/"},{"frontmatter":{"title":"[OMSCS] 조지아텍 컴퓨터공학 석사 과정 준비 및 합격 후기","description":"직장 생활과 병행하면서 대학원 석사 과정을 이수하기 위해 조지아텍에 지원했고 합격했습니다. 합격 당시 스펙을 궁금해하는 사람들이 있어 준비 과정을 간략히 공유합니다.","date":"April 12, 2024","category":"essay","tags":["georgia-tech","omscs","admission","university","computer-science","graduate-program"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#2878a8","images":{"fallback":{"src":"/static/ea7c08946cad30c04e27958ab7ae2dff/12a3e/georgia-tech-admission-review-wide.png","srcSet":"/static/ea7c08946cad30c04e27958ab7ae2dff/9d9e0/georgia-tech-admission-review-wide.png 225w,\n/static/ea7c08946cad30c04e27958ab7ae2dff/cc174/georgia-tech-admission-review-wide.png 450w,\n/static/ea7c08946cad30c04e27958ab7ae2dff/12a3e/georgia-tech-admission-review-wide.png 900w,\n/static/ea7c08946cad30c04e27958ab7ae2dff/4dd11/georgia-tech-admission-review-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/ea7c08946cad30c04e27958ab7ae2dff/3f003/georgia-tech-admission-review-wide.webp 225w,\n/static/ea7c08946cad30c04e27958ab7ae2dff/ba134/georgia-tech-admission-review-wide.webp 450w,\n/static/ea7c08946cad30c04e27958ab7ae2dff/e7f7d/georgia-tech-admission-review-wide.webp 900w,\n/static/ea7c08946cad30c04e27958ab7ae2dff/fc420/georgia-tech-admission-review-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"georgia tech admission review cover image"},"id":"9d3042f3-4ac1-5903-af5a-70d60379bc87","slug":"essay/georgia-tech-admission-review/"},{"frontmatter":{"title":"[Swagger] 인터페이스로 어노테이션 분리하기","description":"스프링에서 스웨거를 활용하다보면 컨트롤러에 각종 스웨거 어노테이션을 추가할 일이 생깁니다. 자바 인터페이스를 활용하여 문서화 관련 어노테이션을 컨트롤러로부터 분리해봅시다.","date":"March 27, 2024","category":"development","tags":["spring","swagger","annotation","java","interface","dev-tools","api"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/bf7f55d67a0f66bd2b00ace418fee239/12a3e/swagger-annotations-with-interface-wide.png","srcSet":"/static/bf7f55d67a0f66bd2b00ace418fee239/9d9e0/swagger-annotations-with-interface-wide.png 225w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/cc174/swagger-annotations-with-interface-wide.png 450w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/12a3e/swagger-annotations-with-interface-wide.png 900w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/4dd11/swagger-annotations-with-interface-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/bf7f55d67a0f66bd2b00ace418fee239/3f003/swagger-annotations-with-interface-wide.webp 225w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/ba134/swagger-annotations-with-interface-wide.webp 450w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/e7f7d/swagger-annotations-with-interface-wide.webp 900w,\n/static/bf7f55d67a0f66bd2b00ace418fee239/fc420/swagger-annotations-with-interface-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"swagger image"},"id":"3aab9e4c-49c4-52cd-9b0f-8afa4b7bb06d","slug":"development/swagger-separate-annotations-with-interface/"},{"frontmatter":{"title":"[Swagger] JWT 인증 버튼 셋업 (feat. Bearer 인증)","description":"스웨거를 통해 요청을 보낼 때마다 Authorization 헤더에 매번 JWT 토큰을 입력하는 것은 번거롭습니다. 딱 한번만 JWT 토큰을 설정하고 재활용할 수 있도록 Authorize 버튼을 설정해봅시다.","date":"February 21, 2024","category":"development","tags":["spring","swagger","authentication","authorization","dev-tools","api"],"hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/2d0f0c347f51ad90899272bbec540c2f/12a3e/swagger-wide.png","srcSet":"/static/2d0f0c347f51ad90899272bbec540c2f/9d9e0/swagger-wide.png 225w,\n/static/2d0f0c347f51ad90899272bbec540c2f/cc174/swagger-wide.png 450w,\n/static/2d0f0c347f51ad90899272bbec540c2f/12a3e/swagger-wide.png 900w,\n/static/2d0f0c347f51ad90899272bbec540c2f/4dd11/swagger-wide.png 1800w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/2d0f0c347f51ad90899272bbec540c2f/3f003/swagger-wide.webp 225w,\n/static/2d0f0c347f51ad90899272bbec540c2f/ba134/swagger-wide.webp 450w,\n/static/2d0f0c347f51ad90899272bbec540c2f/e7f7d/swagger-wide.webp 900w,\n/static/2d0f0c347f51ad90899272bbec540c2f/fc420/swagger-wide.webp 1800w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":450}}},"hero_image_alt":"swagger image"},"id":"0ab6e5ae-80b4-50a5-8dcc-82f9e50fab01","slug":"development/swagger-auth-tutorial/"}],"pageInfo":{"currentPage":2,"hasNextPage":true,"hasPreviousPage":true,"pageCount":9,"totalCount":82}}},"pageContext":{"skip":10}},
    "staticQueryHashes": ["1903006949","2193720160"]}